[{"title":"从select到epoll (Updating)","url":"/2022/06/05/从select到epoll(Updating)/","content":"\n　IO多路复用是指一个进程同时监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知进程进行相应的读写操作，与多进程/多线程技术相比，IO多路复用的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销，Linux环境的IO多路复用主要有三种实现，在Linux-2.4内核前是select和poll，自Linux-2.6内核正式引入epoll以来，epoll已经成为了目前实现高性能网络服务器的必备技术\n\n## select的缺陷\n\n　现在select往往被认为是低效而基本不会再被用于大型项目中，其实这也是特定历史时期的产物，select是1984年在BSD里面实现的，那个时代的硬件实在太弱，一台服务器能处理1千多个连接简直就是神一样的存在了，select很长段时间已经满足需求\n\n　select的核心使用方法是 `返回的活跃连接 = select(全部待监控的连接)` ，select()在高并发时是会被频繁调用的，轻微的效率损失都会被“频繁”二字所放大，\n\n## poll的优化\n\n　~\n\n## 高效的epoll机制\n\n　~\n\n### mmap共享内存\n\n　~\n\n### 红黑树\n\n　~\n\n### LT与ET模式\n\n　~\n\n","tags":["Linux","NP"]},{"title":"TCP的流量和拥塞控制 (Updating)","url":"/2022/05/16/TCP的流量和拥塞控制(Updating)/","content":"\n　TCP是可靠的传输层通信协议，也是一个非常复杂的协议，不过TCP涉及的所有内容都是围绕丢包、乱序、流控、拥塞控制这几个问题的，解决了这几个问题，也就能基本保证传输可靠性\n\n## 滑动窗口\n\n　~\n\n## 流量控制\n\n　~\n\n## 长连接\n\n　~\n\n## 拥塞控制\n\n　~","tags":["NP"]},{"title":"从指针到智能指针 (Updating)","url":"/2022/05/09/从指针到智能指针 (Updating)/","content":"\n### 内存和指针\n\n- **位(bit)**\n电子计算机中最小的数据单位\n每一位的状态只能是0或1\n\n- **字节(Byte)**\n用于计量存储容量的一种单位\n每一个字节由8位组成（1 Byte = 8 bit）\n\n- **地址**\n可以理解为在一片内存中，每个字节（Byte）的编号\n\n- **指针(pointer)**\n程序数据在内存中的地址\n在C语言当中，允许用一个变量来存放数据在内存中的地址，这种变量称为指针\n\n![](/img/C++/address.png)\n\n### 指针类型\n\n```\nint a = 1;\nint *p = &a;\nprintf(\"%d: %d\", p, *p);\n```\n\n从硬件内存的角度来看变量a，主要由两部分组成：\n> - 变量在内存中的首地址\n> - 变量在内存中的占用长度（区间）\n\n对应的指向变量a的指针p也有两个属性：\n> - 指针的值 -> 表示变量的首地址\n> - 指针的类型 -> 表示变量的占用长度\n\n以上代码中，\"&\"操作符为取值运算符，可以取出变量a的首地址，\"*\"操作符为间接访问(indirection)或者解引用(dereference)操作符，可以通过变量a的首地址来访问变量a\n\n不管是什么类型的指针变量，所存的值都只是地址（int类型的值），对应变量的首地址，而指针变量的类型则对应了变量的占用长度，通过指定类型的指针变量，就可以完整的访问变量，比如int \\*从指定地址向后寻找4字节作为变量的存储单元，double \\*从指定地址向后寻找8字节作为变量的存储单元\n\n### void指针\n\nvoid指针是一种特别的指针，是因为它没有类型，或者说这个类型不能判断出指向对象的长度\n\n```\nint a = 1;\nint *p = &a;\n\n// 任何类型指针都可以赋值给void指针\nvoid *vp = p;\n\n// void指针赋值给其他类型的指针时都要进行强制类型转换\nint *pp = (int *)vp;\n\n// 直接解引用*vp非法，也不能进行指针运算，除非先进行强制类型转换\nprintf(\"%d: %d\", *p, *(int *)vp);   \n(int *)vp++;   // 直接解引用*vp非法\n```\n\n### 非法指针\n\n- **悬垂指针**\n如果指针指向的对象已经被销毁，就被称为垂悬指针\n\n```\nint *p=NULL;\n\nvoid fun()\n{   \n    int i=10;\n    p=&i;\n}\n\nvoid main()\n{\n\tfun(); \n\tcout << \"*p = \" << *p << endl;   // p为垂悬指针\n}\n```\n\n- **野指针**\n野指针是指向“垃圾”内存（非法内存）的指针，任何指针变量刚被创建时不会自动成为NULL指针，他的缺省值是随机的，他可能指向一个非法的地址，所以指针变量在创建的同时一定要被初始化，要么将指针设置为NULL，要么让它指向合法的内存，<u>垂悬指针其实也是一种野指针</u>\n\n```\nint *p;   // p为野指针\n```\n\n### C++11的智能指针\n\n　引入智能指针是为了实现类似于Java中的垃圾回收机制，\n　STL中的auto_ptr和boost中的智能指针都是智能指针的例子\n\n\n### 参考链接\n\n[指针辨析：悬垂指针、哑指针、野指针、智能指针](https://blog.csdn.net/zhaojinjia/article/details/8770989)","tags":["C++"]},{"title":"Linux环境的编译和调试 (Updating)","url":"/2022/05/08/Linux环境的编译和调试 (Updating)/","content":"\n### 编译原理\n\n　从 **编译原理** 角度看，编程语言的编译可以分为几个流程： `词法分析` >> `语法分析` >> `语义分析` >> `中间语言生成` >> `目标代码生成与优化`\n\n- `词法分析`\n首先源代码被输入扫描器（Scanner） ，简单的进行词法分析，通过类似有限状态机（Finite State Machine）的算法，将源代码的字符序列分割成一系列记号（Token）\n\n- `语法分析`\n语法分析器（Grammar Parser）对记号进行语法分析，从而生成语法树（Syntax Tree）\n\n- `语义分析`\n语义分析器（Semantic Analyzer）主要负责静态语义分析，通常包括声明和类型的匹配，类型的转换\n\n- `中间语言生成`\n中间代码使得编译器可以被分为前端和后端，编译器前端负责产生与机器无关的中间代码，编译器后端将中间代码转换为目标机器代码\n\n- `目标代码生成与优化`\n代码生成器（Code Generator）将中间代码转换为目标机器代码\n目标代码优化器（Target Code Optimizer）对目标代码进行优化，比如选择合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等\n\n### 编译器\n\n　而从 **编译器** 角度看，要把源代码编译成可执行文件，主要是要经过 `编译` 和 `链接` 两步，因此一个完整的编译系统一定要包含 `编译器（Compiler）` 和 `链接器（Linker）` 两大功能部件，之所以需要链接器，是因为编译器一次只编译一个源文件（称之为翻译单元 （translation unit）），而一般的程序都是多源文件的，需要链接器把所有翻译单元对应的输出合并成一个可执行文件：\n\n- `编译器` 负责完成编译原理中提到的那些流程，编译器报告的错误一般都是局部错误，会指明错误在哪个文件第几行\n- `链接器` 负责把编译器生成的代码片段拼接成一个完整的可执行程序，链接器报告的错误绝大多数都是多胳膊少腿的问题，比如函数重定义，无法解决的外部符号等，这些错误无法定位到某一行\n\n### GNU编译套件\n\nLinux环境编译套件主要由 GCC（GNU Collect Compiler） 和 GNU Binutils（GNU Binary Utilities） 两部分组成，Binutils与GCC是紧密相集成的，如果没有Binutils，GCC不能正常工作，GCC是一组编译工具的总称，包括 `预处理（cpp）`、`编译器（cc1）`，主要完成的工作任务是“预处理”和“编译”，Binutils提供了一系列用来创建、管理和维护二进制目标文件的工具程序，`汇编（as）`、`连接（ld）`、`反汇编（objdump）`、`elf结构分析工具（readelf）`\n\n![](/img/Linux/gcc.png)\n\n由 cc1、as 和 ld 三个部件分别完成 编译、汇编 和 链接 的工作\n\n- 预编译\n- cc1将C语言源文件编译为汇编文件（.s） <u>gcc test.c -S -o test.S</u>\n- as将汇编代码转换为二进制指令，生成大家都很熟悉的对象文件（.o） <u>as test.S -o test.o</u>\n- 生成的这些对象文件再由ar打包成静态库（.a），或者由ld连接成可执行程序（elf或者.so） <u>ld test.o -o test</u>\n\n对于编译单个源文件一步到位生成可执行文件 gcc test.c -o test 相当于上面三个步骤的组合，中间文件被放置在临时目录下\n\nobjdump反编译\n\n### GDB调试\n\n\n### Linux环境的基本依赖库\n\nC语言标准主要由两部分组成，一部分描述C的语法，另一部分描述C的标准库，C标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型声明和宏定义，要在一个平台上支持C语言，不仅要实现C编译器，还要实现C标准库，这样的实现才算符合C标准\n\n**<u>（ I ）libc.so</u>**\nlibc库即C运行库（C Runtime Library），glibc是gnu发布的C运行库，Linux环境曾经普遍使用libc作为C运行库，后来逐渐被glibc取代，glibc是目前Linux平台上最广泛使用的C函数库，主流的一些linux操作系统如 Debian, Ubuntu，Redhat等（包括变种）用的都是glibc\n\nglibc包括C标准库的实现，也包括所有系统调用，是linux系统中最底层的API，几乎其它任何运行库都会依赖于glibc，glibc提供一组头文件和一组库文件，最基本、最常用的C标准库函数和系统函数在libc.so库文件中，glibc除了封装linux操作系统所提供的系统调用外，它本身也提供了许多其它一些必要功能服务的实现，很多linux的基本命令，比如cp, rm, ll, ln等，都得依赖于它\n\n如果对C运行库进行错误操作或者升级失败会导致系统命令不能使用，严重的造成系统退出后无法重新进入，所以操作时候需要慎重\n\n版本查看命令： <u>strings /lib64/libc.so.6 | grep GLIBC</u>\nglibc开发者文档： https://developer.gnome.org/glib/\nglibc源码地址： http://ftp.gnu.org/gnu/glibc\n\n**<u>（ II ）libgcc_s.so</u>**\nlibgcc是GCC提供的一个低层运行时库，当一些操作/运算在特定平台上不支持时，GCC会自动生成对这些库函数的调用，使用这些库函数来模拟实现\n\n从源码实现中，可以分为libgcc1和libgcc2，libgcc1中包含了一套基础操作/运算，这些无法使用其它操作来实现，通常会使用一系列的汇编代码来模拟完成，libgcc2通过已有的一些操作/运算来简单的组合完成。通常是使用C代码来编写，它们最终会被编译合并为libgcc.a\n\n版本查看命令： <u>strings /lib64/libgcc_s.so.1 | grep GCC</u>\nlibgcc详细文档： https://gcc.gnu.org/onlinedocs/gccint/Libgcc.html#Libgcc\n\n**<u>（ III ）libstdc++.so</u>**\nlibstdc++提供了C++程序的标准库，但并不与内核打交道，对于系统级别的事件，libstdc++首先是会与glibc交互，才能和内核通信，相比glibc来说，libstdc++就显得没那么基础了\n\n版本查看命令： <u>strings /usr/lib64/libstdc++.so.6 | grep GLIBCXX</u>\n\n**<u>（ IV ）libpthread.so</u>**\nlibpthread.so库对应的头文件是pthread.h，实现了POSIX线程库，标准的Linux多线程库","tags":["Linux"]},{"title":"C++的指针和引用 (Updating)","url":"/2022/05/06/C++的指针和引用 (Updating)/","content":"\n### 指针常量和常量指针\n\n　指针常量和常量指针其实就是两种不同的指针，但是中文翻译的相当粗糙，把次序颠倒一下反而更能达意\n\n- **指针常量**\n常量型指针，指针指向的地址不允许修改，但是指向变量的值可以修改\n\n```\nint a,b;\nint * const p = &a;   // 指针常量\n\n*p = 9;   // 合法\np = &b;   // 报错\n```\n\n- **常量指针**\n指向常量的指针，指针指向变量的值不允许修改，但是指向的地址可以修改\n\n```\nint a,b;\nconst int *p = &a;   // 常量指针\n\n*p = 9;   // 报错\np = &b;   // 合法\n```\n\n### 引用的本质\n\n　**<u>在C++中，引用(reference)其实就是通过指针来实现的</u>** ，引用实现是在编译器层面完成，在语言层面对程序员做了透明化处理，引用的本质是一个指针常量，`int &p = a`等价于`int * const p = &a`，也因此引用在初始化之后不能改变指向其它变量，相对而言，引用比指针更安全\n\n- **引用和指针的对比**\n> - 引用在定义时必须初始化；指针可以在任何时候初始化(除了指针常量)\n> - 引用在初始化后不能改变指向其它变量；指针可以在任何时候更改\n> - 引用必须指向有效的变量；指针可以为NULL\n> - sizeof引用得到的是所指向的变量的大小；sizeof指针得到的是对象地址的大小\n\n### 函数的参数传递\n\n　发生函数调用时，会把实参的值传送给被调函数的形参从而实现向被调函数的数据传送，形参出现在函数定义中，作用域是整个函数体，每次调用函数时，都会重新创建该函数所有的形参，然后用实参来初始化对应的形参\n\n- **传值参数（包括传指针）**\n传值参数是C语言中唯一的传参方式，在使用实参初始化形参时，将实参的值拷贝一份到形参，有一些博客甚至教材将传指针列为值传递以外的另一种传参方式，如果看到这种三流文章基本可以直接扔了\n\n- **传引用参数**\n引用传递是C++中才支持的传参方式，在C语言中不支持，引用传递并没有拷贝操作，而是利用引用的特点，将引用类型的形参绑定到实参上，从而达到可以直接操作实参的效果，使用引用传参既可以直接改变原变量值，也可以避免拷贝，提高效率\n\n- **GetMemory()的陷阱**\n曾经在腾讯面试遇到一道基础题目，找出以下代码的问题\n\n```\nvoid GetMemory(char *p)\n{\n    p = (char *)malloc(100);\n}\n\nvoid Test(void)\n{\n    char *str = NULL;\n    GetMemory(str);\n    strcpy(str, \"hello world\");\n    cout << str << endl;\n}\n```\n\n这段代码实际上会引起Crash，调用GetMemory(char *p)时，并不是真正传入指针，而是发生了一次值传递，拷贝了NULL到形参，因此并没有改变原指针的地址，通过引用传递，就可以很好地解决这个问题\n\n```\nvoid GetMemory(char* &p)\n{\n    p = (char *)malloc(100);\n}\n\nvoid Test(void)\n{\n    char *str = NULL;\n    GetMemory(str);\n    strcpy(str, \"hello world\");\n    cout << str << endl;\n}\n```\n\n当然，如果使用指向指针的指针，也可以解决\n\n```\nvoid GetMemory(char **p)\n{\n    *p = (char *)malloc(100);\n}\n\nvoid Test(void)\n{\n    char *str = NULL;\n    GetMemory(&str);\n    strcpy(str, \"hello world\");\n    cout << str << endl;\n}\n```\n\n### C++11的左值和右值引用\n\n\n### 参考链接\n\n[C++中“引用”的底层实现](https://blog.csdn.net/pql925/article/details/74937585)\n[对C++引用的理解](https://zhuanlan.zhihu.com/p/417209733)\n[C/C++语言中函数参数的传递](https://xhy3054.github.io/c-cpp-argu-passing/)\n","tags":["C++"]},{"title":"OpenWrt固件编译","url":"/2022/01/25/OpenWrt固件编译/","content":"\n　OpenWrt是基于Linux的开源路由器固件，不过官方放出的固件功能非常有限，基本只提供了基础功能，如果要实现去广告、科学上网和内网穿透等各种功能，就需要自己折腾安装插件，而OpenWrt插件又存在着碎片化问题，不同硬件和内核下，插件并不通用，常常出现各种安装失败问题\n\n　Lean大在OpenWrt官方源码的基础上做了修改和定制，额外添加多个常用插件，比如SSR Plus+，Lionel大则支持比如PassWall等插件，两套源码整体上比较相似，可以根据源码配置参数，选择自己需要的功能，直接手动编译生成针对自己硬件平台的固件\n\n　OpenWrt固件编译过程中需要下载很多依赖，其中大部分资源都在墙外服务器，可在VULTR上临时部署一台VPS来进行编译，推荐部署Cloud Compute / High Performance系列（High Frequency系列虽然CPU频率高一点但是架构比较老），2CPU+80G以上空间（编译会占用约30G空间），系统推荐Ubuntu 18.04 LTS x64，VULTR大多线路不是很稳定，用过的里面Singapore稳定性稍好\n\n### 准备Ubuntu环境\n\n- **更新软件源**\n\n```\napt update\napt upgrade\n```\n\n　最初的Ubuntu包管理命令被分散在了 `apt-get`、`apt-cache`、`apt-config` 这三条命令中，`apt` 命令的引入就是为了解决命令过于分散的问题，`apt` 命令包含了 `apt-get`、`apt-cache`、`apt-config` 这三条命令中最常用命令选项的集合，而且用 `apt` 命令安装或者删除程序时能看到进度条\n\n- **安装编译依赖**\n\n```\napt -y install build-essential asciidoc binutils bzip2 curl gawk gettext git libncurses5-dev libz-dev patch python3.5 python2.7 unzip zlib1g-dev lib32gcc1 libc6-dev-i386 subversion flex uglifyjs git-core gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils upx libelf-dev autoconf automake libtool autopoint device-tree-compiler g++-multilib antlr3 gperf\n```\n\n- **修改SSL配置**\n\n```\n# 防止因为长时间没有操作而导致SSH自动断开\nvi /etc/ssh/sshd_config\n\n# 修改完成后重启sshd服务生效\nservice sshd restart\n```\n\n![](/img/OpenNet/OpenWrt_06.png)\n\n### 创建非root用户\n\n　Lean/Lionel固件要求使用非root用户进行编译，尝试用root用户编译会遇到一些奇奇怪怪的报错，切换到非root用户编译后就一路顺风\n\n- **创建非root用户**\n\n```\nuseradd -m summer -d /home/summer -s /bin/bash\n```\n\n- **修改用户权限文件sudoers，为非root用户提权**\n\n```\nchmod +w /etc/sudoers\n\n# User privilege specification\nroot　  ALL=(ALL:ALL) ALL\nsummer　ALL=(ALL:ALL) ALL\n\nchmod -w /etc/sudoers\n```\n\n### 下载更新源码\n\n　以下操作切换到非root用户目录，全部以非root用户执行\n　\n- **拉取OpenWrt源码**\n\n```\ncd\ngit clone -b 21.02 --single-branch https://github.com/Lienol/openwrt openwrt\ncd openwrt\n```\n\n- **将PassWall源码clone到package目录**\n\n```\n## 这种方法在OpenWrt_21里面已经失效\ncd package\ngit clone https://github.com/xiaorouji/openwrt-passwall\n\n## 在Lionel固件中添加SSR Plus+编译会报错\n#git clone https://github.com/fw876/helloworld\n```\n\n- **添加OpenClash源码到package目录**\n\n```\ncd\nwget https://github.com/vernesong/OpenClash/archive/master.zip\nunzip master.zip\ncp -r OpenClash-master/luci-app-openclash openwrt/package\n```\n\n### 编辑OpenWrt配置\n\n```\n./scripts/feeds clean\n./scripts/feeds update -a\n./scripts/feeds install -a\nmake menuconfig\n```\n\n- 选择系统(以 x86_64 为例)\nTarget System -> x86\nSubtarget -> x86_64\n\n![](/img/OpenNet/OpenWrt_01.png)\n\n- 选择固件的文件系统\nTarget Images -> squashfs\n\n- 选择构建X86_X64的GRUB固件\nTarget Images -> Build GRUB images (Linux x86 or x86_64 host only) \n\n- 选择更小的压缩格式固件，方便复制\nTarget Images -> GZip images\n\n- 修改软件包可用空间，默认安装会占用100M左右，修改扩容为后续安装其他软件打基础\nTarget Images -> Root filesystem partition size\n\n![](/img/OpenNet/OpenWrt_02.png)\n\n- 排除dnsmasq，由于默认会安装dnsmasq-full，需要排除dnsmasq，否则会冲突报错\nBase system -> dnsmasq\n\n- 添加kmod-tun，TUN模式必须，建议也勾选kmod-tcp-bbr\nKernel modules -> Network Support -> kmod-tun\n\n- 添加wget\nNerwork -> File Transfer -> wget-nossl\nNerwork -> File Transfer -> wget-ssl\n\n![](/img/OpenNet/OpenWrt_03.png)\n\n- 添加web界面\nLuCI > Collections -> Luci\n\n- 添加兼容性依赖\nLuCI > Modules -> luci-compat\n\n- 添加中文\nLuCI > Modules -> Translations -> Chinese Simplified\n\n- 添加主题\nLuCI -> Themes\n\n- 最后也是最重要的，添加openclash和其他需要的ipk\nLuCI > Applications -> luci-app-openclash  \nLuCI > Applications -> Luci-app-turboacc\nLuCI > Applications -> Luci-app-vnstat2\n\n![](/img/OpenNet/OpenWrt_07.png)\n\n### 修改初始IP地址\n\n```\ncd\nvi openwrt/package/base-files/files/bin/config-generate\n```\n\n![](/img/OpenNet/OpenWrt_05.png)\n\n### OpenWrt固件编译\n\n```\n## 下载dl库\n## -j8: 使用8个线程\n## V=s: 为故障排除目的提供更详细的信息\nmake -j8 download V=s\n\n## 第一次编译推荐使用-j1单线程\n## 尝试使用2CPU+j4第一次可编译通过，大概一个半小时左右\n## 但是使用4CPU+j4第一次还是会报错\nmake -j4 V=s\n```\n\n　编译完成后的固件在openwrt/bin/targets/x86/64/目录下 :)\n","tags":["OpenNet"]},{"title":"MOTO_Milestone刷机步骤","url":"/2021/05/18/MOTO_Milestone刷机步骤/","content":"\n### 准备工作\n\n- **安装milestone驱动**\n下载最新版官方驱动，在电脑上解压并安装\n[Motorola Moto XT702 Driver](https://motorolausbdriver.com/download/motorola-moto-xt702)\n\n- **安装RSD Lite**\n下载最新版RSD Lite，在电脑上解压并安装\n[RSD Lite Tool](https://rsdlitetool.com/rsd-lite-v6-2-4)\n\n- **下载GOT底包**\n解压后放在某个磁盘根目录下备用（路径不能有中文，.sbf格式底包名字也不能有中文）\n\n- **下载OpenRecovery**\n解压后得到的update.zip和OpenRecovery文件夹，都放到手机tf卡的根目录下（不要改名）\n\n- **下载ROM包**\n下载后不用解压直接放到手机tf卡/OpenRecovery/updates文件夹下（路径严格一致）\n\n### 刷底包\n\n请确保手机有不少于60%的电量，刷机过程中，电脑不要断电，也不要拔USB线\n\n- 关闭手机\n\n- 推开键盘，按住“方向上键”＋“电源键”不放，保持约5后松开，手机屏幕显示进入bootloader界面\n\n- 用USB连接手机和电脑，电脑设备列表中出现Flash设备，说明连接正常\n\n- 打开RSD Lite，分别选中.sbf格式的GOT底包，以及bootloader状态的手机\n\n- 在RSD Lite上点击“START”开始刷底包，手机可能会自动重启两次，一直到RSD界面显示“PASS”，刷底包完成\n\n![](/img/DGtler/RSD-Lite.png)\n\n### 刷OpenRecovery\n\n- 关闭手机\n\n- 查看Bootloader版本号\n推开键盘，按住“方向上键”＋“电源键”不放，保持约5后松开，手机屏幕显示进入bootloader界面，屏幕上方显示版本号，90.73/90.74/90.75或者90.78\n\n- 关闭手机\n90.73/74/75系列版本，按住“拍照键”和“电源键”，出现moto的标志后松开，等待出现黄色的感叹号\n90.78系列版本，按住物理键盘的”X键“和”电源键“，出现moto的标志后松开，等待出现黄色的感叹号\n\n- 先按住 “音量上键”再按“相机键”进入recovery列表\n\n- 刷OpenRecovery\n推开键盘，用“方向键”选择 “apply sdcard：update.zip”\n\n- 进入OpenRecovery后，用“方向键”选择“wipe data/factory reset”，然后选择“yes”\n\n### 刷ROM包\n\n界面再次刷新后，回到了OpenRecovery主界面\n\n- 使用“方向键”选择并点击“apply update”\n\n- 使用“方向键”选择并点击ROM包\n\n- 使用“方向键”选择并点击“yes”，这时候会显示刷机的进度条，当滚动条完成，且界面最下面显示“install from sdcard complete”的时候，就说明刷机完成\n\n- 使用“方向键”选择并点击“go back”\n\n- 使用“方向键”选择并点击“Reboot System”，手机会自动重启，看见感叹号，然后按“音量上”和“拍照键”，返回系统recovery\n\n- 使用“方向键”选择并点击\"Reboot System now\"\n","tags":["DGtler"]},{"title":"Mr.范特西的甜腻Mojito","url":"/2020/11/01/Mr.范特西的甜腻Mojito/","content":"\n## 甜腻Mojito\n\n　今年周杰伦又出了新单曲《Mojito》，点开MV就像点开一个很久没联系的朋友的社交网站，他身上岁月的痕迹显而易见，不过取代少年感的却是一种拒绝长大的违和感，新歌MV如同他instagram里展现的喜气洋洋的日常——五彩斑斓的古董车、火辣漂亮的女孩、簇拥身边的好兄弟，所有人唱唱跳跳，没有烦恼，甜腻而塑料\n\n![](/img/随笔/Jay_01.png)\n\n　其实相比近年几首毫无记忆点的单曲，《Mojito》的旋律还算好听，基本回到了甜水歌水平，但也仅此而已，只是充满批发感流水线生产的好听，跟周杰伦黄金时代的那些经典歌曲，差了大概几十条街，不少同学聚会上，偶遇曾经暗恋到死去活来的男生，却发现对方已经变成暴发户，锐气消逝，身材发福，英俊不再，不过一身名牌名表名车却时时提醒着别人自己如今的地位，谈吐间刻意流露出成功人士的身份，不禁感慨，曾经的爱过是真心爱过，现在的嫌弃也是嫌弃到骨子里，而今天的周杰伦，也让人有着相似的感觉\n\n　写这篇文章的时候，我重新去听Jay的一张张专辑MV，从2000年横空出世的《Jay》到《十一月的萧邦》，今天听来依然惊喜，那时的Jay热衷于音乐实验，把古典音乐放进流行歌，把各种不同风格的音乐混搭在一起，编曲也聪明有趣，《可爱女人》前奏是一声口哨和直升机轰鸣，《三年二班》用乒乓球就打出了节拍，Jay还总是喜欢开创先河，《东风破》后，“中国风”歌曲开始席卷，但大都是对他的拙劣模仿，Jay把妈妈的名字当专辑名，他还让所有人看到，流行歌可以像电影，每首歌都有一本小说的想象空间，《以父之名》令人想到《教父》，《夜的第七章》是贝克街探案，《最后的战役》中学生被裹挟上战场，想到“冰棒汽水的味道”，看到同伴“侧脸倒在我怀里”，是海因里希·伯尔的《流浪人，你若到斯巴...》\n\n　《依然范特西》是周杰伦的第七张个人专辑，许多更年轻的歌迷表示从这时开始喜欢周杰伦，但这张专辑其实是Jay下坡路的开始，《范特西》是Jay的第二张专辑，取fantasy的音译，名副其实天马行空，《简单爱》《双节棍》《爱在西元前》等经典都出自于此，豆瓣上，超过14万人给出平均9.2分，而《依然范特西》给人一种不祥的预感——Jay开始重复自己了，果然，《夜的第七章》和《以父之名》很像，《千里之外》让人想到《东风破》，这张专辑豆瓣得分7.7分，之前六张专辑的平均得分为8.5分，而在《依然范特西》之后，周杰伦的后七专辑平均6.9分，《惊叹号》只有5.6分\n\n![](/img/随笔/Jay_02.jpg)\n\n　2007年，周杰伦推出专辑《我很忙》，整张专辑除了《青花瓷》，闪光点并不多，以往的艺术质感不见了，《以父之名》《止战之殇》被《阳光宅男》《牛仔很忙》取而代之，没有一首歌能有以前那样广阔的想象空间，落差大到令人不可思议，这也是周杰伦后七张专辑带给很多歌迷的普遍感受——一种震惊的失落，好像从小玩的最好的朋友，上大学后突然陌生了，谈吐、审美变化大到几乎不认识，无法理解是如何道不同到这种地步的\n\n## 丢失的范特西\n\n　今天再听《我很忙》，终于意识到了那种巨大落差背后的原因，从《我很忙》开始，周杰伦作品里的自我认知和爱情观变了，过去的Jay内敛、害羞，却有藏起来的厉害，是那种有野心却不说出来的人，在自卑和自恋之前摇摆，维持着微妙的平衡，让人觉得可爱，比如学妹替他报名参加超级新人王，他不想去，觉得一定会丢脸，参赛当天紧张到腹泻，回来却轻描淡写的说，“我去了，而且赢咯”，被吴宗宪签下后，有段时间他在吴宗宪的餐厅打工，某一天刘德华出现在餐厅，同事希望引荐他给天王认识，“你的机会来了”， 让他好好表现，他却连连表示“不要了”，他天天窝在办公室写歌，吃睡都在那里，后来他在极短的时间里写了50首歌，吴宗宪挑了其中10首，为他出了第一张专辑《Jay》，不想出名的人被才华出卖，不得不被簇拥至台前，这是童话故事，也是歌迷的运气\n\n![](/img/随笔/Jay_03.jpg)\n\n　那个时候的周杰伦之所以能够吸引大批年轻的歌迷，大概也是因为一个不被认可的小孩，却有暗暗较劲的志气，凡事都要做到最好，这让年轻人有代入感，他映射着我们不被认可、偷偷自负的自我，但从《我很忙》开始，那种劲儿劲儿的少年感突然像个响指般消失了，他的自我定位换成了万人瞩目的大明星，他开始乐于展现八块腹肌，被性感美女簇拥，背景总是欧洲都市别墅城堡，里面是镶嵌水钻的跑车和钢琴，一群小弟跟着热舞，对此周杰伦显然十分享受\n\n　过去，Jay的歌曲里面爱是克制、是开不了口，混合着热烈和胆怯，像塞林格《破碎故事之心》那样，是想触碰又缩回手，他并不擅长作词，却写出过非常质朴感人的情歌，比如《晴天》，“消失的下雨天，我还想再淋一遍，没想到失去的勇气我还留着”，而在后来的故事里，他摇身一变成了受欢迎的把妹达人和夜店王子，为小弟们提供指导，《阳光宅男》里，周杰伦俨然一个泡妞专家，教刻板印象中“像刚出土的文物”的宅男追女神，“露出胸膛，约会要等，来电显示给个甜蜜的昵称”，“让美女缺氧，靠在你肩膀”，最后再和穿比基尼的女神在海滩奔跑\n\n　自恋从可爱到可厌之间的界限，微妙却不可逾越，伴随着自我认知的颠覆，以及对爱情观的改变，在周杰伦的后七张专辑里，女性也被脸谱化成两种形象：\n\n　一种是单纯少女，为男友默默守候，像《我不配》《好久不见》里那样，安静等待男友联络，小情绪不要太多，在男友眼里她们更像宠物，“你需要人宠爱，天天叫你baby”，他们还拥有无限付出的美德，《说好不哭》里，女生辛苦卖奶茶，帮男友申请摄影学校，为男友买高价相机，强颜欢笑送男友追梦，得到的报酬是理所当然的接受和一点感激，“你什么都没有，却还为我的梦想加油”\n\n　另一种是引诱男生的妖艳心机女，女性形象被物化成“画着爱心的水晶指甲，烟熏妆这么浓”，“长腿窄裙”，她们擅长的举止是“对我撒娇，扭水蛇腰，不吵不闹”，“撒娇，讨好，我收到”，从《摩杰座》开始，MV中大堆无意义的性感美女劲歌热舞无休无止，沦为一个性感符号\n\n　以前不是这样的，从《Jay》到《依然范特西》，Jay歌曲中的女性形象是丰富多样的，拥有灵魂，令人遐想，有《可爱女人》里那样漂亮的、温柔的、坏坏的，《简单爱》里单纯的、透明的，《她的睫毛》里亮丽的、自信的，《园游会》里可爱的、调皮的，《发如雪》里婉郁的、长情的，《迷迭香》里性感的、神秘的\n\n　在严重退步的性别意识下，没有对异性真正的欣赏爱慕，没有令人感同身受的爱情体验，因此，即便已经40岁的周杰伦，歌曲中展现的仍然是想象力匮乏的低龄化幼稚化爱情，比如《等你下课》里跟踪狂式的暗恋，《告白气球》那种环游世界耍浪漫 —— 花哨、甜腻、没烦恼，这让人感到像在餐厅里看无聊的情侣在谈无聊的恋爱，一口蛋糕喂来喂去就是不吃下去的那种尴尬\n\n　这十几年里，周杰伦的生活也发生了变化：他结婚，成为父亲，只是这些变化似乎并没有让他获得崭新而丰沛的人生阅历，因此反映在创作中他那种复杂的、细腻的生活体验到校园为止，鲜活生动的歌也只能到小男生的异想和恋爱，之后就是无止尽的重复，以及经过记忆美化后不真实的青春回忆\n\n　除了性别意识和爱情观，从2007年开始，周杰伦在音乐上的退步，还体现在整个创作格局和视野上，在早期作品中，他呈现出的创作格局是丰富的、多样的，他关注社会问题，能敏感捕捉各种各样的美，觉得颠覆传统有趣，“唱反调是我的个性”，他写过反家暴的《爸，我回来了》，写过反战的《最后的战役》《止战之殇》\n\n　对异域的异想也曾是他创作中最特别的部分，《忍着》是在居酒屋喝味增汤，想象忍者飞檐走壁，《威廉古堡》有文学写作的细节：胖女巫的黑猫笑起来像哭，蓝眼睛的公主专吃AB血型的公老鼠，《米兰的小铁匠》里，小铁匠渴望走进一家烟雾缭绕的酒馆，询问演奏的和弦到底是什么调，异域也制造了无数动人的故事，《以父之名》那样的黑帮火拼，《止战之殇》那样的战时分离，《四面楚歌》那样的谍战故事，但《我很忙》之后，周杰伦似乎也懒的为异域精心编故事了，他像个旅游宣传大使，从一个欧洲城市换到下一个，网红景点转一转，梦却造不出来了，一听到他还在唱“古旧城市”这种划水歌词，简直身心俱疲\n\n　周杰伦终于变成了成功的正面榜样，但也同步变得懒惰麻木，缺乏反思，更不用说反叛，他的价值观躺在舒适区，审美标准日益单一，他写迎合时代、不动脑筋的口水歌，“宅男”“女神”“废柴”统统进入歌名，《稻香》是后期周杰伦为数不多能打动我的歌，他好不容易把目光从王子一样的自己身上移开，探讨比自恋和甜水歌更深刻的社会话题：普通人怎么样才能找到真正的平静和幸福？因此《稻香》也成为了周杰伦黄金时代过去后，唯一一首再次获得普遍认可的歌\n\n　很多Jay的八零九零后歌迷，听着Jay一首首歌曲长大时，也一直努力想要不惧权威，努力想要将自己喜欢的事情做到最好，只是多年过后回头一看，却失望的发现，曾经那个有古堡情节的害羞男生，再也没有写出《威廉古堡》那样可爱生动的歌，他终于可以拥有古堡，但古堡只是道具，好衬托周杰伦这个弹水晶钢琴的40岁王子\n\n## 寻找周杰伦\n\n　2007年之后，周杰伦到底怎么了？很多忠实歌迷都想知道这个问题的答案，2007年，周杰伦离开吴宗宪成立的阿尔法音乐，《我很忙》之前的专辑皆由该公司发行，他和填词人方文山、前阿尔法总经理杨峻荣创立自己的公司杰威尔音乐，身为老板的周杰伦，除了创作，还有太多事情需要操心，看得出他很照顾提携朋友，后期MV多了很多他携多名艺人热舞的镜头，亲朋好友也以喜感角色纷纷亮相，然而相比之前的电影质感，后期MV质量大打折扣，更像是KTV劲舞的堆砌，毕竟成为话事人后，出专辑应该不会像以前那样辛苦，写50首歌淘汰40首，而身为老板，听到的赞美应该也会比批评多得多\n\n　2007年之后，周杰伦个人的兴趣点也发生了变化，此前音乐是他唯一的工作重点，只有2005年在《头文字D》出演一名和他本人性格几乎一模一样，沉默、努力的天才车手，作为新人，他表现不错，因此获得了金像奖和金马奖的最佳新人奖，2007年，他自导自演的电影《不能说的秘密》上映，反响大好，此后他在电影方面投入了大量的精力，只是成果并不显著，《大灌篮》《青蜂侠》《天台爱情》...豆瓣均分5.6分\n\n　还有商业，周杰伦开潮牌店、开餐厅、投资KTV和健身房，组建自己的电竞战队......这些的确让他赚到了更多的钱，他也似乎变成了一位成功的商人，但这些商业项目大多都建立在粉丝买单的基础上，我曾经的大学门口就开着周杰伦旗下的KTV真爱范特西，是他对自己影响力的一种变现，而非有计划的商业版图扩张，也看不出他想做出真正有影响力、有传承价值的商业品牌的野心\n\n　2014年的马来西亚演唱会上，周杰伦说了一句曾经很火的话，“即将上市的新专辑，我写了12首歌，听就好，可以不用买，因为我不是靠这个挣钱的”，这句话几乎可以被视作一个象征，音乐上的成功，是周杰伦商业价值的基础，但当音乐已经不再为他提供主要金钱收益时，他似乎也失去了对音乐的敬畏和追求，在说过“我不靠这个挣钱”一个月后，号称周杰伦首张个人数字音乐专辑的《哎哟，不错哦》上市，有歌迷听过后在豆瓣上写到，“他不缺才华，只缺诚意”\n\n　最近几年，周杰伦的创作量进一步减少，开演唱会成了他赚钱的重要方式之一，他的演唱会越开越多，2013到2015年，他举办了76场世界巡回演唱会，随后2016到2019年，这个数字变成了120场，但演唱会也成了他表演敷衍、划水的重要舞台，2004年开无与伦比系列演唱会时，他会先唱好几首歌再说话，话也不多，就几句，但很诚恳，“很感动，大家冒着风雨来到这边，所以等一下我会尽力的表演，谢谢你们”，而近些年的周杰伦演唱会，老歌降调唱，朋友伴唱甚至帮唱，闲聊比唱歌多，甚至嘉宾唱的歌也比他多，他的懈怠肉眼可见，几乎呈现出一种“老油条”的状态，恨不得时时看表，划水到下班，赚钱走人\n\n　尽管演唱会的门票年年秒空，但我从未动过去现场看演唱会的念头，因为实在无法面对曾经害羞、社恐的偶像变成了腰缠万贯的话痨，露出八块腹肌，背着镶满水钻的吉他，攥着闪闪发光的话筒，唱那些消费校园情怀的幼稚情歌\n\n## 拒绝长大的Jay\n\n　作为曾经的天王、几代人的校园记忆，如今的很多歌迷对周杰伦普遍宽容到宠爱，新歌不怎么样，是因为“生活太幸福了，没感想”，“他只是一个歌手，不要给他赋予莫名其妙的使命感”，只要他开心，歌迷就知足了，但我并不这么认为，这并不是一个“老去的天才开心就好”的问题，这是“一个人要如何对待自己”的问题，天才的才华流失、水平下降可以接受，他们完全有资格退休、享受生活，完全可以，但顶着天才的名气，持续不断的生产庸俗的、劣质的产品，是我们不能、也不应该接受的，所以令我无法接受的，不是周杰伦江郎才尽、止步不前，而是他的敷衍和糊弄，或许他没有对不起我们，他只是对不起自己，以及自己的这份才华\n\n　我欣赏的另一个音乐人窦唯，年轻时是偶像，年长后是大师，某种程度上，窦唯和周杰伦也有相似之处，同样从小学习音乐，年少成名，是当时的叛逆标杆，窦唯20几岁时也是另类偶像，曾经的魔岩三杰，担纲摇滚乐队黑豹的主唱，红磡演唱会几乎让当时的香港奉为天人，对大陆摇滚音乐有开创式影响，但与周杰伦不同，随着年龄的增加，窦唯从一个热闹的青年偶像，变成了一位音乐匠人，他醉心于自己更加纯粹的音乐，他不再介意受众，对音乐有更加自我、小众的探索，音乐成为他延续哲学思考的方式\n\n![](/img/随笔/Jay_04.jpg)\n\n　《依然范特西》专辑里，周杰伦写过一首歌《红模仿》，歌词这样写道，“我坚持风格，我活在我的世界，但我的肩膀，会有两块空地，那就是勇气与毅力，我要做音乐上的皇帝”，但他没有，他甚至没有陪着我们一起长大，没有像我们一样去学着负担生命的重量，去学着面对笑和泪，面对爱与失去，去学着成为称职的丈夫和妻子，还有父亲和母亲，去学着和岁月和解，然后一同洒脱老去，周杰伦还是赖在青春期，但也没有像20几岁时的他那样，一次次带我们冲出庸俗时代的包围圈，打破想象力的极限，关注更多人的挣扎和苦痛，把流行歌唱得像诗，像电影，像艺术\n\n　周杰伦当然是才华横溢的天才，如今也算得上成功的商人和老板，只是他可能永远也不明白，或者不想去明白，这个有时候看起来并不那么美好的世界，其实并不缺他如今所拥有的金钱和荣耀，缺的是他曾经的才华和想象力，缺的是他歌里写过的“勇气与毅力”，还有看透生活的真相后，依然敢于热爱生活的英雄主义\n\n![](/img/随笔/Jay_05.png)","tags":["随笔"]},{"title":"字符编码 (via C++) (Updating)","url":"/2020/03/02/字符编码 (via C++)(Updating)/","content":"\n　每个程序猿都会遇到字符编码问题，自己刚开始工作时总是花费大量时间在解决字符编码问题上，理顺字符编码的发展历史和机制，理解背后的原理，能少走很多弯路\n\n## 字符编码标准\n\n### ASCII码\n\n　计算机最初主要在美国发展，用8个bit组成一个字节(Byte)，8-bit的字节一共可以组合出256(2的8次方)种不同的表示，完全可以满足英语系国家的使用需求，ANSI(American National Standards Institute)于是制定了ASCII编码标准(American Standard Code for Information Interchange，美国信息互换标准代码)，用0~127来表示控制符、标点符号、数字、大小写字母\n\n### GB2312码\n\n　ASCII码能满足英语系国家使用，但是对于中国这样的拥有上万汉字的国家，1个字节显然不可能满足使用，为了表示汉字，同时避免和ASCII编码冲突，规定小于127的字节意义与原来相同，将2个大于127的字节组合表示汉字，前面的一个字节（高字节）的值在0xA1到0xF7之间，后面一个字节（低字节）的值在0xA1到0xFE之间，这种汉字方案就是GB2312编码标准，GB2312编码一共收录了7445个字符，包括6763个简体汉字和682个其它符号\n\n### GBK码\n\n　GB2312编码标准于1980年制定，满足了日常使用，但是对于一些生僻汉字和繁体字，GB2312编码标准就不够用了，于是1995年又推出了GBK扩展编码标准，不再要求低字节要大于127，GBK编码完全兼容GB2312编码的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号，但目前的多数搜索引擎都不能很好的支持GBK汉字\n\n### BIG5码\n\n　BIG5编码是通行于台湾、香港地区的繁体字编码方案，和GB2312码的编码方式类似，将2个大于127的字节组合表示汉字，第一个字节的值在0xAO到0xFE之间，第二个字节在0x40到0x7E之间，收录了13461个汉字和符号\n\n### Unicode码\n\n　类似GB2312和BIG5这样的编码方式被统称为DBCS（Double Byte Charecter Set，双字节字符集），DBCS的每个字符可以包含一个字节或者两个字节，在DBCS系列标准里，最大的特点是2字节长的汉字字符和1字节长的英文字符并存于同一套编码方案里，解码时必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了，然而新的问题却又出现了，不同地区采用了不同的DBCS编码方案，比如同样显示汉字，大陆使用GB2312编码，而台湾使用BIG5编码，拷贝不同地区的文件常常出现乱码的情况\n\n　为了解决不同的DBCS编码方案冲突的问题，Unicode.org制定了UCS编码标准（Universal Character Set，通用字符集），也就是Unicode码，Unicode.org定义了百万个以上的字符，如果将世界上所有的字符用统一的格式表示，需要4个字节才能满足要求，实际上，这就是UTF-32（UCS Transfer Format）方案，是Linux平台上所使用的Unicode方案，但是其实绝大部分字符只使用2个字节就可以满足表示了，这就是Windows平台默认采用的UTF-16方案，而对于欧洲和北美，只需要一个字节就可以表示所有的字符，UTF-16方案依然存在很大的空间浪费，于是采用了很灵活的UTF-8方案\n\n　UTF-8是一种可变长度字符编码方案，用1~6个变长字节来表示Unicode标准中的任何字符，和IP的分址算法很相像，映射关系如下：\n\n　UTF-32 <-> UTF-8\n\n　0x00000000 - 0x0000007F <-> 0xxxxxxx\n\n　0x00000080 - 0x000007FF <-> 110xxxxx 10xxxxxx\n\n　0x00000800 - 0x0000FFFF <-> 1110xxxx 10xxxxxx 10xxxxxx\n\n　0x00010000 - 0x001FFFFF <-> 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n　0x00200000 - 0x03FFFFFF <-> 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n　0x04000000 - 0x7FFFFFFF <-> 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n## Window字符转换\n\n### ANSI编码是什么鬼？\n\n　Windows系统中可以选择使用ANSI编码，选择编码格式为ANSI编码，输入汉字后居然能正常显示不乱码，很多程序猿可能会很困惑中文并没有ANSI这种编码格式，然而把ANSI编码的文件发到台湾的PC上同样选择ANSI编码打开，居然又会是乱码的，这就让人更加困惑\n\n　其实ANSI并不是某一种特定的字符编码，而是在不同的Windows系统中，表示不同的编码，欧美的系统中ANSI编码是ASCII编码，大陆的系统中ANSI编码其实是GBK编码，台湾的系统中ANSI编码又变成了BIG5编码，韩文系统中ANSI编码是EUC-KR编码，日文系统中ANSI编码是JIS编码，Window系统中用“Windows code pages”来判断系统默认编码，在命令行下执行chcp命令可以查看当前code page的值\n\n　通过宏A2W()和W2A()，可以把字符串在ANSI编码和Unicode编码之间转换\n\n```\n// 使用ATL的W2A和A2W宏必须使用USES_CONVERSION\nUSES_CONVERSION;\n\n// Unicode >>> ANSI\nwchar_t* wszText = L\"Unicode字符转换为ANSI\";\nprintf(\"%s\\n\", W2A(wszText));\n\n// ANSI >>> Unicode\nchar* szText = \"ANSI字符转换成Unicode\";\nwprintf(L\"%s\\n\", A2W(szText));\n```\n\n### 宏_T(\"x\")和宏L\"x\"\n\n　_T()是一个适配宏，作用是让程序支持Unicode编码，当#ifdef _UNICODE的时候，_T就是L，没有#ifdef _UNICODE的时候，_T就是ANSI\n\n```\n#define _T(x) __T(x)\n  ...\n#ifdef  _UNICODE\n　#define __T(x) L ## x\n#else  \n　#define __T(x)  x\n```\n\n　不管以什么方式编译，宏L\"x\"一律以Unicode方式保存\n\n### 宽字符和多字符编码\n\n　Windows编程中，C++基本数据类型中表示字符的有两种，分别是char和wchar_t，wchar_t表示宽字节字符集，每个字符的编码宽度都相等，均是两个字节，而char表示多字节字符集，每个字符的编码宽度都不等，可以是一个字节，也可以是多个字节，string是普通的多字节版本，是基于char的，对char数组进行的一种封装，wstring是Unicode版本，是基于wchar_t的，对wchar_t数组进行的一种封装\n\n　WideCharToMultiByte()将宽字符编码转换为多字符编码，函数原型如下：\n\n```\nint WideCharToMultiByte( \nUINT CodePage, \nDWORD dwFlags, \nLPCWSTR lpWideCharStr, \nint cchWideChar, \nLPSTR lpMultiByteStr, \nint cbMultiByte, \nLPCSTR lpDefaultChar, \nLPBOOL lpUsedDefaultChar \n);\n\n// CodePage: 指定要转换成的字符集代码页\n// CP_ACP  当前系统ANSI代码页 \n// CP_OEMCP  当前系统OEM代码页，一种原始设备制造商硬件扫描码 \n// CP_UTF8  设置UTF-8时lpDefaultChar和lpUsedDefaultChar都必须为NULL \n\n// 宽字符编码转换为多字符编码\nwstring wstr_Src(L\"test\");\nint nBufferSize = WideCharToMultiByte(CP_ACP, 0, wstr_Src, -1, NULL, 0, NULL, NULL);\nchar *ptrch_Target = new char[nBufferSize+1];\nWideCharToMultiByte(CP_ACP, 0, wstr_Src, -1, ptrch_Target, nBufferSize, NULL, NULL);\nstring str_Dest(ptrch_Target);\ndelete []ptrch_Target;\n```\n\n　MultiByteToWideChar()将多字符编码转换为宽字符编码，函数原型如下：\n\n```\nint MultiByteToWideChar( \nUINT CodePage, \nDWORD dwFlags, \nLPCSTR lpMultiByteStr, \nint cbMultiByte, \nLPWSTR lpWideCharStr, \nint cchWideChar \n); \n\n// 多字符编码转换为宽字符编码\nstring str_Src(L\"test\");\nint nBufferSize = MultiByteToWideChar(CP_UTF8, 0, str_Src.c_str(), -1, NULL, 0);\nwchar_t *ptrwch_Target = new wchar_t[nBufferSize+1];\nWideCharToMultiByte(CP_UTF8, 0, str_Src.c_str(), -1, ptrwch_Target, nBufferSize);\nwstring wstr_Dest(ptrwch_Target);\ndelete []ptrwch_Target;\n```\n\n## 参考链接\n\n[Unicode 和 UTF-8 有何区别？](https://www.zhihu.com/question/23374078)\n\n[ANSI是什么编码？](http://www.cnblogs.com/malecrab/p/5300486.html)\n\n[MultiByteToWideChar()与WideCharToMultiByte()的参数详解](http://www.cnblogs.com/wanghao111/archive/2009/05/25/1489021.html)\n\n\n","tags":["程序猿的自我修养"]},{"title":"TCP的三次握手和四次挥手","url":"/2020/02/24/TCP的三次握手和四次挥手/","content":"\n　TCP（Transmission Control Protocol // 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义，是互联网最基本也是最重要的协议\n\n## TCP的帧格式\n\n　TCP帧封装在IP帧中，TCP头紧接着IP头\n\n![](/img/NP/Net_Layer.png)\n\n　TCP的每一帧由Header和Payload两部分组成，不带Option的TCP Header最短，长度为20 Bytes，带Option的TCP Header最长可达60 Bytes\n\n![](/img/NP/TCP_Frame.png)\n\n　也顺便对比下UDP的帧结构，UDP的头部非常简单，长度固定不变为8 Bytes\n\n![](/img/NP/UDP_Frame.png)\n\n## TCP帧的各个字段\n\n- **源端口（Source Port）[16 bit]**\n源端口是发送方程序对应的端口，和源IP地址+源端口唯一标识报文发送端的地址\n\n\n- **目的端口（Destination Port）[16 bit]**\n目的端口指明报文接收方程序对应的端口\n\n\n- **序列号（Sequence Number）[32 bit]**\n发送序号(SN)标识了TCP报文中第一个Byte在对应方向的传输中对应的字节序号，TCP通过SN对每个字节进行计数，**通过发送序号，保证了网络包不会乱序**，<u>TCP流的初始序列号(ISN)并不是从0开始，而是从一个随机数开始，当SN达到u32最大值后，序列号会回绕到0</u>\n\n\n- **确认应答号（Acknowledgment Number）[32 bit]**\n确认应答号标识了准备接收的包的下一个序号，<u>确认序号应该已经成功收到的数据字节顺序号加1</u>\n\n\n- **首部长度（Header Length）[4 bit]**\n首部长度标识数据从何处开始，有些地方也被称为数据偏移，标识TCP头部长度，比如偏移值为0101，则说明TCP头部长度为 5*4=20 Bytes\n\n\n- **保留（Reserved）**\n这些位必须是0，为了将来定义新的用途所保留\n\n\n- **窗口大小（Window Size）[16 bit]**\n标识当前接收端的接收窗口还有多少剩余空间，用于TCP的流量控制\n\n\n- **校验和（Checksum）[16 bit]**\n发送端基于数据内容计算校验和，接收端要与发送端数值结果完全一致，才能证明数据的有效性，接收端Checksum校验失败的时候会直接丢掉这个数据包，校验和覆盖了整个TCP报文段，包括TCP首部和TCP数据\n\n\n- **紧急指针（Urgent Pointer）[16 bit]**\n优先指针和发送序号相加表示紧急数据最后一个字节的序号，在URG标志置位时才有效\n\n\n- **选项（Option）**\n长度不确定，不超过40 Bytes，必须是32 bit的倍数，常见的选项包括MSS、SACK、Timestamp等等\n\n\n#### 6位标志位\n\n- **URG(Urgent)**\n标识Urgent Pointer字段是否有效，紧急标志位目前已经很少使用到\n\n\n- **ACK(Acknowledgment)**\n标识Acknowledgment Number字段是否有效\n\n\n- **PSH(Push)**\n该标志置位时，一般是表示发送端缓存中已经没有待发送的数据，接收端不将该数据进行队列处理，而是尽可能快将数据转由应用处理\n\n\n- **RST(Reset)**\n通常在发生异常或者错误的时候会触发复位TCP连接\n\n\n- **SYN(Synchronize)**\nSYN标志仅在三次握手建立TCP连接时有效\n\n\n- **FIN(Finish)**\nFIN标志仅在四次挥手断开TCP连接时有效\n\n\n## TCP通讯时序\n\n![](/img/NP/TCP_Life.jpg)\n\n### TCP的三次握手\n\n![](/img/NP/TCP_SYN.png)\n\n- **第一次握手**\nClient将标志位SYN置1，随机产生一个值seq=x，并将数据包发送给Server，Client进入 **SYN_SENT** 状态，等待Server确认\n\n- **第二次握手**\nServer收到标志位SYN=1的数据包，表示Client请求建立连接，Server将标志位SYN和ACK都置1，随机产生一个值seq=y，并将数据包发给Client确认连接请求，Server进入 **SYN_RCVD** 状态\n\n- **第三次握手**\nClient收到确认后若ACK为1，则将该数据包发送给Server，Server检查ACK为1则连接建立成功，Client与Server都进入 **ESTABLISHED** 状态完成三次握手，可以开始正式传输数据\n\n通过三次握手双方可以确认收发功能都正常，另一个更重要的目的是确认对方的初始序列号（Initial Sequence Number）\n\n### 为什么不能两次握手？\n\n- **确认双方的收发能力**\n由于TCP连接是全双工的，因此需要确认客户端与服务端双方的收发包是否正常，第一次握手完成后，服务端可以确定客户端发包和自己收包正常，第二次握手完成后，客户端可以确定服务端收发包都正常，自己的收发包也正常，但是此时服务端还不能确定自己的发包是否正常，只有完成第三次握手，双方才可以都完成确认\n\n- **序列号可靠同步**\n\n- **阻止重复历史连接的初始化**\n客户端由于某种原因发送了两个不同序号的SYN包，由于网络环境的复杂性，旧的数据包可能反而先到达服务端，如果是两次握手，服务端收到旧的SYN就会立刻建立连接，将会造成网络异常\n如果是三次握手，服务端需要回复SYN+ACK包，客户端会对比应答的序号，如果发现是旧的报文，就会给服务器发RST报文，直到正常的SYN到达服务器后才正常建立连接，所以三次握手才有足够的上下文信息来判断当前连接是否是历史连接\n\n### 三次握手可以携带数据吗？\n\n　第一次、第二次握手不可以携带数据，而对于第三次握手，此时客户端已经知道服务端的接收、发送能力是正常的，所以可以携带数据是情理之中\n\n### TCP的四次挥手\n\n![](/img/NP/TCP_FIN.png)\n\n　由于TCP连接是全双工的，因此每个方向都必须单独进行关闭\n\n- **第一次挥手**\nClient（也可以是Server端）发送一个FIN，用来关闭Client到Server的数据传送，Client进入 **FIN_WAIT_1** 状态\n\n- **第二次挥手**\nServer收到FIN后，发送一个ACK给Client，Server进入 **CLOSE_WAIT** 状态，Client收到后进入 **FIN_WAIT_2** 状态，这时TCP连接处于半关闭状态，Client已经没有数据要发送了，但是Server若发送数据，Client依然要接受\n\n- **第三次挥手**\nServer发送一个FIN，用来关闭Server到Client的数据传送，Server进入 **LAST_ACK** 状态\n\n- **第四次挥手**\nClient收到FIN后，发送ACK给Server，进入 **TIME_WAIT** 状态，等待2MSL后进入 **CLOSED** 状态，Server则是直接进入 **CLOSED** 状态，结束了TCP连接\n\n### 为什么不能三次挥手？\n\n　因为TCP是全双工通信，在主动关闭方发送FIN包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的FIN包与对客户端的ACK包合并发送，只能先确认ACK，然后服务器待无需发送数据时再发送FIN包，所以需要四次挥手，但如果接收端收到FIN包时已经没有数据要发送，那么也可以把FIN和ACK包合并发送，通过三次挥手来关闭连接\n\n### 为什么要进入TIME_WAIT状态等待？\n\n　理论上四个报文都发送完毕，两边都可以直接进入CLOSE状态，正式关闭全双工的TCP连接，但是实际情况是必须假设网络是不可靠的，有可能最后一个ACK丢失，所以主动发起TCP连接关闭的一方必须等待2MSL（最大报文段生存时间），TIME_WAIT状态就是用来重发可能丢失的ACK报文，TIME_WAIT状态中所需要的时间典型值为30秒、1分钟和2分钟，等待之后TCP连接正式关闭，并且所有的资源(包括端口号)都被释放\n\n　进入TIME_WAIT状态等待的另一个原因是为了避免新旧连接混淆，使下一个新的连接中不会出现这种旧的连接请求报文，2MSL确保新连接建立前老的报文都已在网络中消逝\n\n## TCP的半连接和全连接队列\n\n　在TCP三次握手的时候，Linux内核会维护两个队列\n- 半连接队列，也称 SYN 队列\n- 全连接队列，也称 accept 队列\n\n　服务端收到客户端发起的SYN请求后，内核会把该连接存储到半连接队列，并向客户端响应SYN+ACK，接着客户端会返回ACK，服务端收到第三次握手的ACK后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到accept队列，等待进程调用accept()函数时把连接取出来，不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回RST包\n\n![](/img/NP/TCP_Queue.png)\n\n\n### 参考链接\n\n[淘宝二面，面试官居然把TCP三次握手问的这么详细](https://www.eet-china.com/mp/a44399.html)\n[小林 x 图解网络](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86)","tags":["NP"]},{"title":"C++类的成员","url":"/2019/06/24/C++类的成员/","content":"\n### 类的6个默认成员函数\n\n![](/img/C++/class.jpeg)\n\n\n- **<u>构造函数</u>**\n构造函数负责给每个数据成员分配一个合适的初始值，构造函数名和类名相同，支持函数重载\n构造函数没有返回值，因为如果构造函数允许指定返回类型，而刚好返回值类型又是带参构造函数的参数类型，就会产生语法歧义\n构造函数不能用const修饰，因为const修饰的函数不能修改成员变量，但是构造函数需要修改类的成员变量\n构造函数也不能是虚函数，虚函数机制需要通过虚指针VPTR指向虚表VTABLE来实现，但是调用构造函数之前类对象还没有实例化\n\n\n- **<u>析构函数</u>**\n析构函数没有参数，也没有返回值\n析构函数负责完成数据成的销毁，实例对象生命周期结束时，系统会自动调用析构函数\n\n\n- **<u>拷贝构造函数</u>**\n拷贝构造函数是构造函数的重载\n拷贝构造函数只有一个形参，必须使用同类对象的引用\n编译器自动生成的拷贝构造函数只会完成浅拷贝（值拷贝）\n\n\n- **<u>赋值运算符重载</u>**\nC++为了增强代码的可读性引入了运算符重载，其目的就是让自定义类型可以像内置类型一样可以直接使用运算符进行操作\n类的赋值运算符重载使用引用返回，返回值为该类型的引用，没有参数\n\n\n- **<u>取址运算符重载和cosnt修饰的取址运算符重载</u>**\n取址运算符重载没有参数，返回值为该类型的指针（this）\n\n\n```\n// String类的成员函数\n\nclass String\n{\npublic:\n\tString(const char* str = NULL);   // 构造函数 // 调用时如果不传参数，就默认参数为NULL\n\t~String();                        // 析构函数\n\tString(const String& other);      // 拷贝构造函数\n\tString& operator=(const String& other);   // 赋值运算符重载\n\tString* operator&();               // 取址运算符重载\n\tconst String* operator&() const;   // cosnt修饰的取址运算符重载\nprivate:\n\tchar *m_data;\n}\n\n// 构造函数\nString::String(const char* str)\n{\n\tif(str == NULL)\n\t{\n\t\tm_data = new char[1];\n\t\t*m_data = '\\0';\n\t}\n\telse\n\t{\n\t\tint length = strlen(str);\n\t\tm_data = new char[length+1];\n\t\tstrcpy(m_data, str);\n\t}\n}\n\n// 析构函数\nString::~String()\n{\n\tdelete[] m_data;\n\tm_data = NULL;\n}\n\n// 拷贝构造函数\nString::String(const String& other)\n{\n\tint length = strlen(other.m_data);\n\tm_data = new char[length+1];\n\tstrcpy(m_data, other.m_data);\n}\n\n// 赋值运算符重载\nString& operator=(const String& other)\n{\n\t// 自赋值检查\n\tif(this == &other)\n\t\treturn *this;\n\telse\n\t{\n\t\tdelete[] m_data;\n\t\tint length = strlen(other.m_data);\n\t\tm_data = new char[length+1];\n\t\tstrcpy(m_data, other.m_data);\n\t\treturn *this;   // *为解引用操作符\n\t}\n}\n\n// 取址运算符重载\nString::String* operator&()\n{\n\treturn this;\n}\n\n// cosnt修饰的取址运算符重载\nconst String::String* operator&() const\n{\n\treturn this;\n}\n```\n\n### 类的成员\n\n- **成员变量**\n类内有多个成员变量，在使用初始化列表进行初始化时，成员变量的初始化顺序是按照定义成员变量顺序决定的，而不是按照初始化列表赋值的顺序决定，而如果使用构造函数进行初始化，则按照构造函数中的先后顺序来初始化\n\n- **inline成员函数**\n如果在类体中定义的成员函数不包括循环等控制结构，一般C++编译器会把他们默认作为inline成员函数，而如果在类体内仅仅是声明，在类体外定义的成员函数，如果要作为内联函数，则需要加上inline关键字\n\n### 浅拷贝和深拷贝\n\n- **浅拷贝**\n在未定义显式拷贝构造函数的情况下，会调用默认拷贝函数，即浅拷贝，浅拷贝能完成成员变量的一一复制，当成员变量中没有指针时，浅拷贝是可行的，然而当成员变量中存在指针时，浅拷贝会将成员指针的地址拷贝给新的成员指针，当其中一个对象先释放时，会导致出现垂悬（悬空）指针，另一个对象也释放时，会造成程序崩溃\n\n- **深拷贝**\n当类的成员变量中有指针时，必须使用深拷贝，深拷贝会在堆内存中申请另外的空间来存储数据（参照上面String类的成员函数），从而避免两个指针指向同一个地址引发的问题\n","tags":["C++"]},{"title":"动态链接库和静态链接库","url":"/2019/05/30/动态链接库和静态链接库/","content":"\n　现实中实现一个软件项目，总是要依赖很多成熟的库，就像造一辆车，不可能也没有必要从轮子开始造车，直接使用别人现成的轮子，这样开发者可以把精力和时间放在项目中最核心的部分，库是软件项目中最重要的基石之一\n\n### 什么是库？\n\n　库的本质非常简单，其实就是写好的、可供调用的代码，现实中每个程序都要依赖很多基础的底层库，不可能每个项目的代码都从零开始，因此库的存在意义非常重要\n\n　从实现上看，库是一种可执行代码的二进制形式，可以被操作系统载入内存执行，根据链接阶段的时间不同，库可以分为两种：静态链接库（.lib、.a）和动态链接库（.dll、.so）\n\n![](/img/Windows/Lib-01.png)\n\n### 为什么要使用库？\n\n- **封装代码，避免剽窃**\n\n\t在项目中，常常需要开放接口给其他合作者或者客户调用，很多情况下，需要开放的代码中可能包含了自己的核心专利技术，我们并不想公开这部分代码，我们可以将代码封装成为库，这样对方可以方便调用我们的接口，但又不暴露自己的代码\n\n- **便于程序员合作**\n\n\t库真正实现了跨语言，对系统以及应用程序来说，哪种语言生成的库是没有区别的，在一个大型项目中，不同的程序员负责不同的部分，可能大家使用的语言也不相同，合作编译就成了一个大问题，有了库，大家只需要把自己的部分封装成库，供主程序调用\n\n- **提高程序可维护性**\n\n\t这个有点同样主要针对动态链接库，因为应用程序需要时才将动态链接库载入内存，使用动态链接库就让程序的可维护性变得很高，如果想要升级某一个模块，不再需要去重新改主程序的代码，或者重新编译打包程序，只需要升级替换对应模块的动态链接库就可以了\n\n### 静态链接库和动态链接库的区别\n\n　根据链接阶段的时间不同，库可以分为两种：静态链接库（.lib、.a）和动态链接库（.dll、.so）\n\n　静态链接库采用静态链接方式，在链接阶段，会将汇编生成的目标文件.o与静态链接库一起链接打包到可执行文件中，既然静态链接库可以和目标文件.o一起链接为可执行文件，说明静态链接库可以和目标文件.o格式很类似，其实本质上静态链接库就是一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件\n\n　然而静态链接库却对于空间和时间存在着两个“浪费”问题：\n\n- **空间浪费问题：**如果2000个文件都链接了某一个静态链接库，那么这个静态链接库在内存中就会有2000份copy，浪费了不必要的内存空间\n\n- **时间浪费问题：**如果应用程序链接的一个静态链接库哪怕只做了一个小小的改动，也要对应用程序的整个工程重新编译、链接，浪费了不必要的等待时间\n\n![](/img/Windows/Lib-02.png)\n\n　静态链接库的这两个“浪费”问题，在动态链接库上得到了完美的解决，动态链接库在程序编译时并不会被链接到可执行文件中，而是在可执行程序运行是才被载入，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题，对于动态链接库的更新改动，也只需要替换动态链接库文件即可，不需要对整个工程全部重新编译，规避了时间浪费问题\n\n![](/img/Windows/Lib-03.png)\n\n### Windows下使用静态链接库(.lib)和动态链接库(.dll)\n\n- **创建静态链接库（.lib）**\n\n\t创建Win32控制台程序时，勾选 “Static library(.lib)” 类型；或者打开工程“Property Pages(属性面板)” -> “Configuration Properties(配置属性)” -> “General(常规)”，将“Configuration Type”设置为“Static library(.lib)”；\n\t\n\tBuild项目就可以生成静态链接库（.lib）\n\n- **使用静态链接库（.lib）**\n\n\t在VS中使用静态库，需要在项目工程属性中添加这个Lib文件的头文件目录和Lib文件目录，最后添加Lib文件：\n\t\n\t(1) 打开“Property Pages(属性面板)” -> “Configuration Properties(配置属性)” -> “C/C++” -> “General(常规)”，在“Additional Include Directories(附加包含目录)”中添加这个Lib文件的头文件目录；\n\t\n\t(2) 打开“Property Pages(属性面板)” -> “Configuration Properties(配置属性)” -> “Linker(链接器)” -> “General(常规)”，在“Link Library Dependencies(附加库目录)”中添加这个Lib文件目录；\n\t\n\t(3) 打开“Property Pages(属性面板)” -> “Configuration Properties(配置属性)” -> “Linker(链接器)” -> “Input(输入)”，在“Additional Dependencies(附加依赖项)”中直接添加静态链接库（.lib）；\n\t\n\t(4) 然后在代码中引用以下两行代码中的任意一行，就可以使用静态链接库\n\t\n\t```\n\t#include \"StaticLibrary.h\"\n\t#pragma comment(Lib, \"StaticLibPath\")\n\t\n\t```\n\n\tVS在在查找静态链接库（.lib）时有一个先后的顺序：先查找指定的附加依赖项，如果没有找到，就从附加库目录中搜索，附加库目录的搜索花费的时间回比较久\n\t\n- **创建动态链接库（.dll）**\n\n\tWindows系统中，dll其实和exe是几乎完全一样的，唯一的不一样就是exe的入口函数是WinMain()函数（console程序是main函数），而dll是DllMain()函数，其他完全一样，所以也可以把dll当成不能自己运行的exe\n\t\n\tVS中创建动态链接库（.dll）会稍微麻烦一些\n\t\n\t(1) 创建Win32控制台程序时，勾选 “Dynamic library(.dll)” 类型；或者打开工程“Property Pages(属性面板)” -> “Configuration Properties(配置属性)” -> “General(常规)”，将“Configuration Type”设置为“Dynamic library(.dll)”；\n\t\n\t(2) 需要一个DllMain函数做出初始化的入口（创建Win32控制台程序时，勾选 “Dynamic library(.dll)” 类型，会自动生成这个文件）\n\n\t```\n\t// dllmain.cpp : 定义 DLL 应用程序的入口点。\n\t#include \"stdafx.h\"\n \n\tBOOL APIENTRY DllMain( HMODULE hModule,\n                       \tDWORD  ul_reason_for_call,\n                       \tLPVOID lpReserved\n                     \t )\n\t{\n\t　switch (ul_reason_for_call)\n\t　{\n\t　　case DLL_PROCESS_ATTACH:\n\t　　case DLL_THREAD_ATTACH:\n\t　　case DLL_THREAD_DETACH:\n\t　　case DLL_PROCESS_DETACH:\n    　　break;\n\t　}\n\t　return TRUE;\n\t}\n\t```\n\n\t(3) 在导出函数的声明时，extern “C”表示要按照C语言的方式编译该函数，防止在C++工程中编译出现函数名错误，因为C++中有函数重载，所以函数名编译后可能会出现Print@1的形式；而且这样也可以让C调用C++的动态链接库；__declspec(dllexport)表示下来的函数是dll的导出函数接口\n\n\t```\n\t/*DynamicLibrary.h头文件*/\n\t \n\textern \"C\" __declspec(dllexport) void Print(void);\n\t```\n\n\tBuild项目即可生成动态链接库（.dll）\n\t\n\t查看生成的动态链接库（.dll）文件，发现同时产生了一个.lib文件，这个.lib文件其实是动态链接库对应的动态导入库，静态链接库同时包含了实际执行代码和地址符号表，动态导入库只包含了地址符号表，实际的执行代码还是位于动态链接库中，动态导入库确保程序找到对应函数的一些基本地址信息\n\n- **隐式调用动态链接库（.dll）**\n\n\t隐式调用动态链接库需要使用上面介绍的动态导入库，动态导入库的调用方法与静态链接库完全一致，唯一的区别就是使用动态导入库编译出来的程序，运行时需要其对应的Dll文件（在同一目录下）\n\n- **显示调用动态链接库（.dll）**\n\n\t显示调用动态链接库有以下步骤：\n\t\n\t(1) 加载dll文件;\n\t\n\t(2) 取得文件内相应函数的指针;\n\t\n\t(3) 使用函数;\n\t\n\t(4) 释放dll句柄;\n\t\n\t```\n\t// 声明函数指针类型\n\ttypedef int(__stdcall *fntest)(char *test);\n\t\n\t// 将dll加载到内存中，用句柄表示\n\tHINSTANSE hLib = ::LoadLibrary(_T(\"DynamicLibrary.dll\"));\n\tif(NULL == hLib)\n\t{\n\t　// error\n\t}\n\tfntest fnsa;\n\t\n\t// 根据dll的句柄得到相应函数的指针\n\tfnsa = (fntest)GetProcAddress(hLib,\"Print\");\n\t\n\t...\n\t\n\t// 使用完后，释放dll句柄\n\t::FreeLibrary(hLib);\n\t```\n\n","tags":["程序猿的自我修养"]},{"title":"命令(Command)模式","url":"/2019/04/19/命令(Command)模式/","content":"\n　当我们去餐厅吃饭，我们通过服务员来点菜，我们只需要关心我们想吃哪些菜，而不需要去关心具体的菜是由谁做的以及这些菜的制作流程，这个场景其实就是一种“命令模式”，我们点的一道道菜就是一个个 `命令(Command)`，帮我们点菜的服务员是命令的 `请求者(Invoker)`，负责做菜的师傅是命令的 `接受者(Reciever)`\n\n### 命令模式的定义\n\n　命令模式将一个请求封装成一个对象，请求者角色与接收者角色之间没有任何依赖关系，实现类间解耦，请求者实现功能时只需调用Command类的execute()方法就可以，不需要知道到底是哪个接收者执行\n\n![](/img/DesignPattern/Command.jpg)\n\n　UML类图中Command的子类ConcreteCommand可以非常容易地扩展，而请求者(Invoker)和高层次的Client模块不产生太多代码耦合\n\n### 命令模式的代码实现(C++)\n\n```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// 烤肉师傅类\nclass RoastCook\n{\npublic:\n　void RoastSteak();\n　void RoastChickenWing();\n};\n\nvoid RoastCook::RoastSteak()\n{\n　cout << \"烤牛排\" << endl;\n}\n\nvoid RoastCook::RoastChickenWing()\n{\n　cout << \"烤鸡翅\" << endl;\n}\n\n// 抽象命令类\nclass Command\n{\npublic:\n　Command(RoastCook *temp) { receiver = temp; }\n　virtual void ExecuteCmd() = 0;\nprotected:\n　RoastCook *receiver;\n};\n\n// 具体命令类 (烤牛排)\nclass RoastSteakCmd : public Command\n{\npublic:\n　MakeMuttonCmd(RoastCook *temp) : Command(temp) {}\n　virtual void ExecuteCmd() \n};\n\nvoid RoastSteakCmd::ExecuteCmd()\n{\n　receiver->RoastSteak();\n}\n\n// 具体命令类 (烤鸡翅)\nclass RoastChickenWingCmd : public Command\n{\npublic:\n　MakeMuttonCmd(RoastCook *temp) : Command(temp) {}\n　virtual void ExecuteCmd() \n};\n\nvoid RoastSteakCmd::ExecuteCmd()\n{\n　receiver->ChickenWing();\n}\n\n// 服务员类\nclass Waiter\n{\npublic:\n　void AddCmd(Command *temp);\n　void Notify();   // 通知执行\nprivate:\n　vector<Command*> m_commandList;\n};\n\nvoid Waiter::AddCmd(Command *temp)\n{\n　m_commandList.push_back(temp);\n　cout << \"增加烤肉订单\" << endl;\n}\n\nvoid Waiter::Notify()\n{\n　vector<Command*>::iterator it;\n　\n　for( it = m_commandList.begin(); it != m_commandList.end(); it++ )\n　{\n　　(*it)->ExecuteCmd();\n　}\n}\n\nint main()\n{\n　RoastCook *cook = new RoastCook();\n　Command *cmdStk = new RoastSteakCmd(cook);\n　Command *cmdChw = new RoastChickenWingCmd(cook);\n　Waiter *waiter = new Waiter();\n　\n　// 增加命令\n　waiter->AddCmd(cmdStk);\n　waiter->AddCmd(cmdStk);\n　\n　// 执行命令\n　waiter->Notify();\n　\n　return 0;\n}\n\n```\n\n\n\n\n","tags":["设计模式"]},{"title":"Shadowsocks服务端安装(Ubuntu 18.04)","url":"/2019/04/18/Shadowsocks服务端安装(Ubuntu 18.04)/","content":"\n　系统环境：Ubuntu 18.04 LTS x64 / pyhton 3.6.7\n\n　上一篇Blog中已经写过Ubuntu 16.04环境Shadowsocks服务端的安装，随着Ubuntu版本更新到Ubuntu 18.04 LTS，虽然Shadowsocks总的安装流程没有变化，但是之前的方法已经不能按步照班\n\n### 更新软件源\n\n```\nsudo apt update\nsudo apt upgrade\n```\n\n　最常用的Linux包管理命令被分散在了 `apt-get`、`apt-cache`、`apt-config` 这三条命令中，`apt` 命令的引入就是为了解决命令过于分散的问题，`apt` 命令包含了 `apt-get`、`apt-cache`、`apt-config` 这三条命令中最常用命令选项的集合，而且用 `apt` 命令安装或者删除程序时能看到进度条\n\n### 安装pip3\n\n```\nsudo apt install python3-pip\n```\n\n　Ubuntu 16.04中内置的python版本还是2.7，Ubuntu 18.04 LTS中内置的python版本已经更新到了3.6，因此不再安装pip，而是安装更为强大的pip3\n\n### 安装Shadowsocks\n\n```\nsudo pip3 install http://github.com/shadowsocks/shadowsocks/archive/master.zip\n```\n\n　通过pip3直接从github中安装最新的版本，安装完后检查是否为3.0.0版本\n\n　这一步可能会报错 `Command “python setup.py egg_info” failed with error code 1 in /tmp/pip-build-7uglwoqt/shadowsocks/` ，原因是Python的包管理工具setuptools已经过期，可以先执行 `sudo pip3 install —upgrade setuptools` ，更新setuptools来解决报错\n\n### 编辑配置文件\n\n```\nsudo vim /etc/shadowsocks.json\n```\n\n　用vim打开Shadowsocks配置文件，并添加以下配置，`\"your_server_ip\"` 和 `\"your_password\"` 需要换成你自己的地址和密码\n\n```\n{\n    \"server\":\"your_server_ip\",\n    \"server_port\":8388,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"your_password\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\"\n}\n```\n\n### 赋予文件权限\n\n```\nchmod 755 /etc/shadowsocks.json\n```\n\n　`chmod` 命令用来变更文件或目录的权限，后面的数字表示不同用户或用户组的权限：\n　\n> - 第一个数字 >> [文件所有者] 的权限\n> \n> - 第二个数字 >> [与文件所有者同属一个用户组的其他用户] 的权限\n>\n> - 第三个数字 >> [其它用户组] 的权限\n\n　权限分为三种：读（r=4），写（w=2），执行（x=1），综合起来还有可读可执行（rx=5=4+1）、可读可写（rw=6=4+2）、可读可写可执行(rwx=7=4+2+1)，所以 `chmod 755` 设置用户的权限为：\n \n> - [文件所有者] 可读可写可执行 --7\n> \n> - [与文件所有者同属一个用户组的其他用户] 可读可执行 --5\n> \n> - [其它用户组] 可读可执行 --5\n\n### 开始运行Shadowsocks\n\n```\nssserver -c /etc/shadowsocks.json -d start\n```\n\n　大功告成 :)\n\n","tags":["OpenNet"]},{"title":"Shadowsocks服务端安装(Ubuntu 16.04)","url":"/2019/04/17/Shadowsocks服务端安装(Ubuntu 16.04)/","content":"\n系统环境：Ubuntu 16.04 x86 / pyhton 2.7.12\n\n### 更新软件源\n\n```\nsudo apt-get update\nsudo apt-get upgrade\n```\n\n　在Windows下安装软件，我们只需exe文件，但是在Linux下可不是这样的，每个Linux的发行版都会维护自己的软件仓库，我们常用的所有软件几乎都在这里，这里的软件绝对安全，RedHat系列Linux发行版的 `yum` 和Debian系列Linux发行版的 `apt-get` 就是最常用获取软件的包管理工具\n\n　Ubuntu系统会在本地维护一个软件源列表，记录软件仓库中的可用软件和相应版本，通过 `apt-get update`，可以更新本地的软件源列表，`apt-get upgrade` 这个命令会把本地已安装的软件，也软件源列表中的软件版本进行逐一对比，如果已安装的软件版本太低，就会提示更新\n\n### 安装pip环境\n\n```\nsudo apt-get install python-pip\n```\n\n　用 `apt-get install` 命令安装pip，pip是一款常用的python包管理工具，也是Python官方建议的包安装工具，主要是用于安装PyPI上的软件包，功能强大\n\n### 升级pip\n\n```\nsudo pip install --upgrade pip\n```\n\n### 安装Shadowsocks\n\n```\nsudo pip install shadowsocks\n```\n\n　用 `pip install` 命令安装Shadowsocks\n\n### 编辑配置文件\n\n```\nsudo vim /etc/shadowsocks.json\n```\n\n　用强大的文本编辑器vim打开Shadowsocks配置文件，并添加以下配置，`\"your_server_ip\"` 和 `\"your_password\"` 需要换成你自己的地址和密码\n\n```\n{\n    \"server\":\"your_server_ip\",\n    \"server_port\":8388,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"your_password\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\"\n}\n```\n\n### 赋予文件权限\n\n```\nchmod 755 /etc/shadowsocks.json\n```\n\n　`chmod` 命令用来变更文件或目录的权限，后面的数字表示不同用户或用户组的权限：\n　\n> - 第一个数字 >> [文件所有者] 的权限\n> \n> - 第二个数字 >> [与文件所有者同属一个用户组的其他用户] 的权限\n>\n> - 第三个数字 >> [其它用户组] 的权限\n\n　权限分为三种：读（r=4），写（w=2），执行（x=1），综合起来还有可读可执行（rx=5=4+1）、可读可写（rw=6=4+2）、可读可写可执行(rwx=7=4+2+1)，所以 `chmod 755` 设置用户的权限为：\n \n> - [文件所有者] 可读可写可执行 --7\n> \n> - [与文件所有者同属一个用户组的其他用户] 可读可执行 --5\n> \n> - [其它用户组] 可读可执行 --5\n\n### 安装加密模块\n\n```\napt-get install python–m2crypto\n```\n\n　这一步目前在Ubuntu环境下已经不需要，用来支持Shadowsocks的加密模块libcrypto已经被内置在Ubuntu 16.04系统中\n\n### 开始运行Shadowsocks\n\n```\nssserver -c /etc/shadowsocks.json -d start\n```\n\n　大功告成 :)\n\n","tags":["OpenNet"]},{"title":"Shadowsocks原理","url":"/2019/04/16/Shadowsocks原理/","content":"\n　很多喜欢Google、Youtube、Twitter...又具有折腾精神的墙内原住民，都有一段和GFW作战的VPN折腾史，从乐此不疲渐渐疲惫不堪，直到clowwindy大神说\"要有光\"，于是便有了Shadowsocks，迅速成为了比VPN更适合翻墙的利器，下面把Shadowsocks的原理简单梳理一下\n\n### 很久很久以前...\n\n　很久很久以前，当天朝还没有GFW(Great Firewall of China，中国国家防火墙，俗称“墙”)，网民们访问各种网站都是简单而直接的，用户的请求通过互联网直接发送到服务提供方，服务提供方直接将信息反馈给用户\n\n![](/img/OpenNet/SS_01.png)\n\n### 出现了一堵墙\n\n　然后有一天，GFW就出现了，GFW像一堵墙一样夹在了在用户和海外服务之间，每当用户需要获取海外服务，都需要经过GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发GFW的过滤规则的时候，就会收到 `Connection Reset` 这样的响应内容，而无法接收到正常的内容 \n\n![](/img/OpenNet/SS_02.png)\n\n### 用代理绕过墙\n\n　聪明的人们想到了利用海外服务器代理的方法来绕过GFW的过滤规则，其中包含了各种HTTP代理服务、Socks服务、VPN服务...其中以ssh tunnel的方法比较有代表性：\n\n1) 首先用户和境外服务器基于ssh建立起一条加密的通道；\n\n2~3) 用户通过建立起的隧道进行代理，通过ssh server向真实的服务发起请求；\n\n4~5) 服务通过ssh server，再通过创建好的隧道返回给用户\n\n![](/img/OpenNet/SS_03.png)\n\n### 然而...\n\n　由于ssh本身基于RSA加密技术，所以GFW无法从数据传输的过程中，获取用户真实的服务请求与过滤规则进行比较，避免了被重置链接的问题\n\n　但由于创建隧道和数据传输的过程中，ssh本身的特征非常明显，所以GFW通过分析连接的特征进行干扰，导致ssh存在被定向进行干扰的问题\n\n### Shadowsocks出现\n\n　于是clowwindy大神创造并开源了他的解决方案Shadowsocks，简单理解的话，Shadowsocks是将原来 ssh创建的Socks5协议拆开成Server端和Client端，所以下面这个原理图基本上和利用ssh tunnel大致类似：\n\n1&6) 客户端发出的请求基于Socks5协议跟SS Local端进行通讯，由于这个SS Local一般是本机或路由器或局域网的其他机器，不经过GFW，所以解决了上面被GFW通过特征分析进行干扰的问题；\n\n2&5) SS Local和SS Server两端通过多种可选的加密方法进行通讯，经过GFW的时候是常规的TCP包，没有明显的特征码而且GFW也无法对通讯数据进行解密；\n\n3&4) SS Server将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回\n\n![](/img/OpenNet/SS_04.png)\n\n### Shadowsocks未来的一小片乌云\n\n　Shadowsocks近乎完美，然而随着机器学习和AI的越发成熟，干扰Shadowsocks也已经成为了可能，基于机器学习的随机森林算法(Random Forest Algorithm)在探测Shadowsocks流量时已经取得了超过85%的准确率 [IEEE论文地址](http://ieeexplore.ieee.org/document/8048116/?reload=true#full-text-section)\n\n### 题外话\n\n　曾经出现过所谓“增强版”ShadowsocksR引发争议，ShadowsocksR基于Shadowsocks代码进行二次开发，又违反GPL开源协议闭源，clowwindy大神曾经有过如下评论 [GitHub评论原文](https://github.com/shadowsocks/shadowsocks-windows/issues/293#issuecomment-132253168)：\n\n> 我一直想象的那种大家一起来维护一个项目的景象始终没有出现，也没有出现的迹象。维护这个项目的过程中，遇到 @chenshaoju 这样主动分享的同学并不多。很多来汇报问题的人是以一种小白求大大解决问题，解决完就走人的方式来的，然而既不愿提供足够的信息，也不愿写一些自己尝试的过程供后人参考。互帮互助的气氛就是搞不起来。对比下国外的社区差好远。\n\n> 最适合这个民族的其实是一群小白围着大大转，大大通过小白的夸奖获得自我满足，然后小白的吃喝拉撒都包给大大解决的模式。通过这个项目我感觉我已经彻底认识到这个民族的前面为什么会有一堵墙了。没有墙哪来的大大。所以到处都是什么附件回帖可见，等级多少用户组可见，一个论坛一个大大供小白跪舔，不需要政府造墙，网民也会自发造墙。这尼玛连做个翻墙软件都要造墙，真是令人叹为观止。这是一个造了几千年墙的保守的农耕民族，缺乏对别人的基本尊重，不愿意分享，喜欢遮遮掩掩，喜欢小圈子抱团，大概这些传统是改不掉了吧。\n\n\n","tags":["OpenNet"]},{"title":"观察者(Observer)模式","url":"/2019/04/15/观察者(Observer)模式/","content":"\n　软件架构中不同的模块(或者类)之间的关联关系分为 `紧耦合` 和 `松耦合` 两种，紧耦合系统中更新一个模块会导致其它关联耦合模块的变化，在一些要求模块间更加独立的系统中，松耦合显然更为合适，松耦合系统通常是基于消息的系统，观察者模式就是实现松耦合系统的常用方式\n\n　观察者模式可以说是应用最多、影响最广的模式之一，观察者模式建立一对多(Subject-Observer)的依赖关系，并且做到当“一”(Subject)变化的时候，这个“一”的“多”(Observer)也都将被通知\n\n　软件开发中经典的MVC(Model-View-Controller)框架是观察者模式最好的一个实例，使用MVC框架的目的是将Model和View的实现分离，如果View改变，则通过Controller去同步改变Model，而如果Model改变，则通过观察者模式去通知View更新\n\n### 观察者模式的定义\n\n　观察者模式定义对象间的一对多的关系，当一个对象的状态发生改变时，所有关注他的对象都会被通知并被自动更新，这种交互也称为发布-订阅(publish-subscribe)，这个“一”(Subject)称为发布者，这个“一”的“多”(Observer)称为观察者，发布者发出通知时，并不需要知道谁是他的观察者\n\n![](/img/DesignPattern/Observer.jpg)\n\n　UML类图中目标(Subject)对象提供了注册(Attach)和注销(Detach)两个操作接口，对目标感兴趣的对象可以通过这两个操作接口来订阅目标对象，从而成为目标的观察者(Observer)，这样当目标状态改变时，会通过通知(Notify)接口通知所有依赖于他的观察者，所有的观察者接收到通知后，会通过更新(Update)操作接口来做出相应的操作\n\n### 观察者模式的代码实现(C++)\n\n```\n// 模拟通知公司内部员工的场景\n\n#include <iostream>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n// 抽象观察者\nclass Observer;\n\n// 抽象发布者\nclass Subject\n{\npublic:\n　string action;\n　virtual void attach(Observer *) = 0;\n　virtual void detach(Observer *) = 0;\n　virtual void notify() = 0;\nprotected:\n　list<Observer *> observers;\n}\n\nclass Observer\n{\npublic:\n　// 构造函数\n　Observer(string name, Subject *subject)\n　{\n　　this->name = name;\n　　this->subject = subject;\n　}\n　virtual void update() = 0;\nprotected:\n　string name;\n　Subject *subject;\n}\n\n// 具体发布者 - 秘书\nclass Secretary : public Subject\n{\n　void attach(Observer *observer)\n　{\n　　observers.push_back(observer);\n　}\n\n　void detach(Observer *observer)\n　{\n　　list<Observer *>::iterator iter = observers.begin();\n　　while(iter != observers.end())\n　　{\n　　　if((*iter) == observer)\n　　　{\n　　　　observers.erase(iter);\n　　　}\n　　　++iter;\n　　}\n　}\n\n　void notify()\n　{\n　　list<Observer *>::iterator iter = observers.begin();\n　　while(iter != observers.end())\n　　{\n　　　(*iter)->update();\n　　　++iter;\n　　}\n　}\n}\n\n// 具体观察者 - 炒股同事\nclass StockObserver : public Observer\n{\npublic:\n　StockObserver(string name, Subject *subject) : Observer(name, subject){}\n　void update();\n}\n\nvoid StockObserver::update()\n{\n　cout << name << \" 收到消息：\" << subject->action << endl;\n　if(subject->action == \"经理来了！\")\n　{\n　　cout << \"马上关闭股票，装做很认真工作的样子！\" << endl;\n　}\n}\n\n// 具体观察者 - 看球同事\nclass FIFAObserver : public Observer\n{\npublic:\n　FIFAObserver(string name, Subject *subject) : Observer(name, subject){}\n　void update();\n}\n\nvoid FIFAObserver::update()\n{\n　cout << name << \" 收到消息：\" << subject->action << endl;\n　if(subject->action == \"经理来了！\")\n　{\n　　cout << \"马上关闭FIFA，装做很认真工作的样子！\" << endl;\n　}\n}\n\nint main()\n{\n　// 创建发布者\n　Subject *SS = new Secretary();\n　// 创建观察者\n　Observer *SO = new StockObserver(\"stock observer\", SS);\n　Observer *FO = new FIFAObserver(\"fifa observer\", SS);\n　\n　// 加入观察者队列\n　SS->attach(SO);\n　SS->attach(FO);\n　\n　// 通知事件A\n　SS->action = \"去吃饭了！\";\n　SS->notify();\n　cout << endl;\n　\n　// 通知事件B\n　SS->action = \"经理来了！\";\n　SS->notify();\n　cout << endl;\n\n　return 0;\n}\n\n```\n\n\n\n\n","tags":["设计模式"]},{"title":"迭代器(Iterator)模式","url":"/2019/04/15/迭代器(Iterator)模式/","content":"\n　当我们外出旅行，住在酒店看电视的时候，我们使用 `前一频道` 和 `后一频道` 按钮可以很方便的换电视台，当按下 `后一频道` 按钮时，将切换到下一个预置的电视台，我们并不知道也不需要去记几号频道对应的是哪个电视台，当切换频道时，我们只关心电视台播放的内容是不是自己喜欢的\n\n　看电视的场景反应的其实迭代器模式的目的，我们会需要一种方法去顺序的访问某个集合中的每个元素，只需要关心元素的具体内容，并不需要关心其他细节，C++ STL中访问各种容器的iterators，就是一个迭代器的实例\n\n### 迭代器模式的定义\n\n　迭代器模式提供一种方法访问一个容器对象中的各个元素，而不暴露该对象的内部细节，迭代器是为容器对象服务的，分离了聚合对象与其遍历行为，迭代器提供了遍历容器的方法，容器只需要管理增减元素，遍历的工作就交给迭代器完成\n\n![](/img/DesignPattern/Iterator.jpg)\n\n　UML类图中抽象迭代器(Iterator)除了提供next()接口，经常也会提供first()、currentItem()、isDone()等接口\n\n### 迭代器模式的代码实现(C++)\n\n```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntemplate<class Item>\nclass Iterator\n{\npublic:\n　virtual void first()=0;\n　virtual void next()=0;\n　virtual Item* currentItem()=0;\n　virtual bool isDone()=0;\n　virtual ~Iterator(){}\n};\n\ntemplate<class Item>\nclass ConcreteAggregate;\n\ntemplate<class Item>\nclass ConcreteIterator : public Iterator<Item>\n{\npublic:\n　ConcreteIterator(ConcreteAggregate<Item> *a):aggr(a),cur(0){}\n　\n　virtual void first()\n　{\n　　cur=0;\n　}\n　\n　virtual void next()\n　{\n　　if(cur < aggr->getLen())\n　　cur++;\n　}\n　\n　virtual Item* currentItem()\n　{\n　　if(cur < aggr->getLen())\n　　　return &(*aggr)[cur];\n　　else\n　　　return NULL;\n　}\n\n　virtual bool isDone()\n　{\n　　return (cur >= aggr->getLen());\n　}\n\nprivate:\n　ConcreteAggregate<Item> *aggr;\n　int cur;\n};\n\ntemplate<class Item>\nclass Aggregate\n{\npublic:\n　virtual Iterator<Item>* createIterator()=0;\n　virtual ~Aggregate(){}\n};\n\ntemplate<class Item>\nclass ConcreteAggregate : public Aggregate<Item>\n{\npublic:\n　ConcreteAggregate()\n　{\n　　data.push_back(1);\n　　data.push_back(2);\n　　data.push_back(3);\n　}\n\n　virtual Iterator<Item>* createIterator()\n　{\n　　return new ConcreteIterator<Item>(this);\n　}\n\n　Item& operator[](int index)\n　{\n　　return data[index];\n　}\n\n　int getLen()\n　{\n　　return data.size();\n　}\n\nprivate:\n　vector<Item> data;\n};\n\nint main()\n{\n　Aggregate<int> *aggr = new ConcreteAggregate<int>();\n　Iterator<int> *it = aggr->createIterator();\n\n　for(it->first(); !it->isDone(); it->next())\n　{\n　　cout << *(it->currentItem()) << endl;\n　}\n　\n　delete it;\n　delete aggr;\n　\n　return 0;\n}\n\n```\n\n\n\n\n","tags":["设计模式"]},{"title":"张学良的1936年","url":"/2019/04/14/张学良的1936年/","content":"\n　离开台湾前的最后一个礼拜，拜访了张学良在新竹清泉山中的的故居，少帅迁来台湾后，一直被蒋介石囚禁在此，这次离职后回到西安这个曾经居住了4年多的城市，特意参观了张学良在西安的公馆，少帅就是在这里策划了“西安事变”，从西安到台湾，记录了自己人生中很重要的一段旅程，很巧合的是，这也正是张学良曾经人生的轨迹，只是少帅的人生划出一道绚烂的曲线，却像流星一样，消失在苍穹之中\n\n![](/img/随笔/张学良_01.jpg)\n　（台湾新竹的张学良故居）\n\n　张学良晚年曾说“自己的生命其实早就结束了，三十五岁那一年就结束了”，张学良的三十五岁那一年，其实就是1936年，这一年的12月，张学良发动了震惊中外的“西安事变”，历史毕竟是后人讲出来的，两岸也都爱讲“西安事变”，有人越讲越有味，有人越讲越变味，讲了八十年，早就已经串了味...2001年，重获自由的张学良在夏威夷檀香山与世长辞，享年一百零一岁，曾经国民党书本里的乱臣贼子，中共眼中的千古功臣，至死也再也没回忆澄清过“西安事变”，任其成了历史上的罗生门\n\n　把时间拨回到回到八十年前，1936年12月12日，张学良软禁了蒋介石，打出口号“停止内战，一致抗日”，然而这两句空泛的口号仅仅只是外因，这样的外因显然并不足以让张学良做出如此极端的选择，真正的内因，更合理的解释恐怕是张学良自己的性格，从小在张作霖的溺爱中长大，张学良从没有受过挫折，成长过程中一帆风顺的命运宠坏了他，在他的性格中留下了至死都无法摆脱的自负，虚荣，还有脆弱的自尊心，只是风华当年的少帅怎么也不会想到，这些最终会酿成自己一生的悲剧\n\n　如果没有“西安事变”，1936年在历史上很可能会被人遗忘，确实这一年的大多数时间都很平淡，好像历史在这一年要打个瞌睡，不过很多事情就像地壳运动，发生在很深很深的地表之下，而并不能被人们所轻易察觉，但是影响却很深远，终有一天，积聚的能量会像火山一样喷发，造成最意想不到的剧烈后果\n\n　1936年初，收拾完各个政敌和军阀的蒋介石环顾中华大地，自己的地盘上似乎不会再有谁能掀起大浪了，而当时的日本，也已经有两年多没有大动作，最后的心腹大患红军，刚刚结束了长征，被赶到陕西，兵力已经不足一万，而且迅速陷入了重兵合围，此时的红军被压缩在陕北几个贫瘠的县，南边有杨虎城的6万西北军，北边是汤恩伯和高桂滋的4个师，东面是阎锡山的10万晋绥军，西边则是宁夏五马的地盘，外围还有胡宗南的中央军虎视眈眈，加起来的兵力总和甚至超过了解放区的老百姓数量，陕北土地贫瘠，气候恶劣，几乎没什么资源，也没有任何工业基础，似乎光是封锁就能饿死红军，在蒋介石看来，红军的灭亡已经是指日可待\n\n　面对已经是瓮中之鳖的红军，蒋介石脑中很快形成了一个一斧三砍的计划，他想到了“九一八”丢失东北的张学良和16万东北军，蒋介石委以张学良消灭红军的任务，并且许诺给了张学良西北的地盘，其实意在让红军和非黄埔嫡系的西北军和东北军三股势力相互消耗，心怀“西北王”抱负的张学良初到陕西，意气风发，以十几万装备精良的东北军优势兵力，对付刚刚经历完长征，看上去已是强弩之末的红军，张学良觉得结果毫无悬念，似乎自己就是来接手地盘的，但是局势的发展很快就出乎张学良的意料，对红军的第一战东北军折损了两个师，接下来的战斗中，东北军屡战屡败，明明已经快弹尽粮绝的红军，似乎突然就有了用不完的子弹，屡屡创造战争奇迹，愈打愈勇，其实不管怎样的奇迹总是有原因的，红军的勇猛背后，隐隐约约闪烁着杨虎城的影子，早在3年前的1933年，张国焘领导的红四方面军刚刚建立川陕革命根据地，杨虎城就派人联系，表达了和平共处的愿望，西北军和红军签了一份秘密协议“汉中协定”，这个协议有两层意思，第一层是双方和平共处，第二层意思有点让人吃惊，如果红军去攻击胡宗南的中央军，西北军不但提供弹药支持，还掩护红军的侧后方，实际上这份条约让西北军和红四方面军已经结成了军事同盟，作为军阀之一的杨虎城和中共签订这个密约其实也不难理解，和红军的火拼必然造成两败俱伤，让蒋介石渔翁得利，只要有蒋介石这只大老虎在旁边蹲着，杨虎城仅仅不打红军是不够的，还要把红军养肥，养寇自重，红军的安全实际上就等于了杨虎城的安全，因此用红军这杆最好的枪去打蒋介石，就成了杨虎城最聪明的选择\n\n　历史学家们往往只注重分析客观因素，而忽略了一些主观的感受，历史人物也是人，也有七情六欲，有些人可以隐藏的很好，把内心澎湃的情感服服帖帖的压在一表斯文之下，这种人是成熟的政客，但张学良恰恰是个反例，年轻的少帅往往意气用事，蒋介石和张学良结拜之后，长兄如父，蒋介石往往长辈自居，更要命的是，军人出身的蒋介石对自己亲近的人，往往也是很严格，刚相识的时候两人多少有些生分，蒋介石勉励多于教训，而随着时间的推移，这种生分就渐渐消失了，刚好这时张学良在军事上又栽了跟头，而这些军事上的不利，就成了张学良失去面子的开端，不过这时还只是张学良噩梦的开始，完全没有意识到风暴已经悄悄向自己扑来，一出悲剧已经拉开了大幕，不可避免，对红军战斗中一连串的失败，终于引发了张学良最不愿意看到的事情，蒋介石的话越说越重，甚至开始了直接的责骂，对于张学良来说，蒋介石的管教过于严厉了，对于一个习惯了仰慕，看惯了笑脸的人，面子当然是最重要的，面子的丧失也就是怨恨的开始，一面是不想打也打不过的红军，一面是蒋介石剿共的压力，这种情况之下，张学良仿佛陷入了一个死循环\n\n　而对于蒋介石和张学良之间日益扩大的裂痕，敏锐的红军领导层却嗅出了另一种可能性，试着向张学良伸出橄榄枝，红军领导层对于说服张学良，开始并没有报以太大的希望，可是没想到已经陷入了人生低谷期的张学良，居然痛快答应了和谈的要求，两个难兄难弟很快就走到了一起\n\n　1936年4月9日，张学良和周恩来见面了，这次会谈似乎从来没有被给予过足够的重视，但是正是这次会谈，却很可能影响了中国未来的走向，是“西安事变”的直接诱因，这次会谈，作为20世纪最伟大的外交家，长袖善舞的周恩来充分展示了自己的外交才华，而张学良也充分证明了自己的年轻冲动，洞察张学良性格弱点的周恩来充分表达了对张学良的尊重，在交谈中不断捧高张学良，真正的强者往往低调，不去计较面子上的得失，尤其在蛰伏的时候，更加不吝啬给别人戴高帽，周恩来甚至表示，未来将在苏联的支持下，由西北的各股军事势力组建西北联军，并且组建西北联合政府，红军愿意接受张学良的领导，而且可以得到苏联的军事支援，这种论调让张学良找回了久违的面子，一个虚妄的憧憬在张学良心中产生了 —— 西北联军总司令，西北联合政府领导人，加上苏联的援助，自己甚至可以打回东北，跟蒋介石分庭抗礼\n\n![](/img/随笔/张学良_02.jpg)\n　（周恩来致张学良的信）\n\n　不久后的6月1日，“两广事变”爆发了，两广的粤桂两系，联合通电，要求“停止内战，一致抗日”，和后来的“西安事变”一模一样的口号，潜台词就是要求蒋介石的中央军停止对地方势力的进逼，多个小势力在一个大势力的压迫之下，大家打出的算盘其实是一样的，这时最正常不过的自保方式，就是在日本人打进来的时候，利用舆论，来打击蒋介石的“攘外安内”政策，这样的手段显然并不是只有红军想到了，其实每一个受到蒋介石胁迫的军政势力都想到了，“两广事变”让各地军阀势力开始暗流涌动，被煽动起来的学生群众也都纷纷组织抗日游行，一时间，蒋介石就处在了舆论的被动局面上，不过熟稔各种政治手段的蒋介石仅仅打出了“封官”和“利诱”两张牌就直接瓦解了粤军主力，整个“两广事变”蒋介石处理的相当精彩，根本没给其他势力留下什么机会\n\n　1936年下半年，处理完“两广事变”的蒋介石终于腾出手来，命令胡宗南的中央军对陕北的红军展开最大力度的打击，仅仅两三个月之内，红军被打的苟延馋喘，随时都有被胡宗南消灭的可能，而这时蒋介石对张学良已经渐渐开始失望，张学良跟蒋介石关系也逐渐恶化，随时都有崩溃的可能\n\n　1936年12月2日，蒋介石电令中央军往陕西方向调动，准备一鼓作气消灭红军，速度之快出乎了张学良和杨虎城的意料，西北联合政府和苏联援助成了张学良唯一的指望，这个梦，无论如何不能破灭了，不然自己的政治生命，恐怕也就到头了\n\n![](/img/随笔/张学良_03.jpg)\n　（西安市张公馆，张学良在此策划了西安事变）\n\n　12月12日，大家熟知的“西安事变”终于爆发了，可是接下来的一幕幕，却完全出乎了张学良的意料，首先，苏联公开谴责，甚至在苏共机关报《真理报》上明确反对，第二，舆论界和大部分知识分子，不分左派右派，集体声讨，而且口号鲜明，直指张学良“假抗日 真叛国”，舆论的一边倒给张学良造成了极大的心理负担，第三，各路军阀不支持，在国内国际的形势之下，没有人想碰这个烫手的山芋，第四，南京政府空前团结，态度强硬，南京政府的飞机在西安上空盘旋示威，部队也向潼关挺进...当历史的车轮毫不留情的向自己碾压的时候，张学良终于绝望了...\n\n　张学良并不是一个合格的军事家，更谈不上是一个称职的政治家，他身上强烈的虚荣天性严重屏蔽了他的政治理性，而脆弱的自尊心又把他在逆境中的坚韧性和抗挫折能力摧毁殆尽，这一切共同驱使他最终走上了失败和灭亡的道路，就像莎士比亚笔下的一个故事，一个人的性格弱点，在复杂的环境里面，被利用，被激发，最后无力自拔，坠入命运的深渊，一切都好像是注定的一般，也确实是被注定的，因为性格决定命运，只是对于注定要在历史上留下浓重一笔的人来说，性格决定的，不单单是自己的命运，甚至左右了国家的前途\n　\n![](/img/随笔/张学良_04.jpg)\n　（台湾新竹的张学良故居）\n\n　再次把时光倒回到八十年前，那是一个一切皆有可能的时代，天堂和地狱或许只在一念之间，贵贱，生死，荣辱，成败，得失...这些貌似矛盾对立的两极，往往在一个阴差阳错的瞬间就已经相互易位，迅捷如闪电，而一个人，能在短暂如烟过眼的一生中，经历什么叫做星移物换，沧海桑田，也能在某个刀光闪过的短暂一秒中，见证什么叫做人生如梦，刹那永恒\n\n　所以那也是一个一着不慎、满盘皆输的时代，历史的大棋盘乍一看风起云涌，龙盘虎踞，可就在不经意的回眸之间，一切都已尘埃落定，张学良命运的弈局开场时精彩无比，少帅曾经自以为手段精妙，纵然走不出吞吐天下的乾坤步，至少也能搏一个逍遥一方的玲珑局，可惜英雄气短，一步走来一步悔，到最后少帅或许会感伤，为什么没有人在开局时就告诫自己：\n\n　小心！落子无悔！\n\n\n","tags":["随笔"]},{"title":"Windows消息结构","url":"/2019/04/13/Windows消息结构/","content":"\n　Windows系统以消息为基础(message based)，以事件为驱动(event driven)，Windows应用程序的进行依靠发生的事件来驱动，事件最终会以消息的形式通知应用程序，因此Windows的消息结构体MSG是Windows系统中最基本、也是最重要的核心之一\n\n### Windows消息结构\n\n　Windows的消息结构体MSG完成声明如下(可查阅MSDN)：\n\n```\ntypedef struct tagMSG\n{\n　HWND hwnd;\n　UNIT message;\n　WPARAM wParam;\n　LPARAM lParam;\n　DWORD time;\n　POINT point;\n} MSG;\n```\n\n- HWND hwnd：表示接受该消息的窗口句柄\n\n- UNIT message：表示消息标识符(消息值)，message是MSG结构体中最重要的成员，也是MSG结构体的核心\n\n\t所有窗口消息定义为具有指定值的宏，用 `WM_` 作为前缀，前缀之后是描述消息名，比如窗口重新确定尺寸的消息值为 `WM_SIZE(0x0005)`\n\n- WPARAM wParam & LPARAM lParam：都是32位的特定附加信息，wParam和lParam的确切含义取决于message消息值，message消息值不同，wParam和lParam表示的附加信息也就不同\n\n\twParam和lParam这两个成员的命名方式是Win16系统时代遗留下来的产物，在Win16 API中WndProc()有两个参数：一个是WORD类型的16位整型变量，另一个是LONG类型的32位整型变量，根据匈牙利命名法，16位的变量就被命名为wParam, 32位的变量就被命名为lParam，到了Win32系统时代中，原来的16位变量也被扩展为32位，因此现在wParam和lParam的大小完全相同\n\n- DWORD time：表示消息送至消息队列的时间\n\n- POINT point：表示消息发送时鼠标在屏幕坐标系中的位置，POINT为嵌套结构成员，他的定义如下：\n```\ntypedef struct tagPOINT\n{\n　LONG x;\n　LONG y;\n} POINT;\n```\n\n### Windows消息分类\n\n　以 `WM_USER` 和 `WM_APP` 两个预定义的宏为界，Windows消息范围可以分为以下几类：\n```\n#define WM_USER  0x0400 \n#define WM_APP  0x8000\n```\n\n- 系统预留消息( Messages reserved for use by the system )\n\n\t消息范围：0 ~ WM_USER – 1\n\n- 自定义窗口类消息( Integer messages for use by private window classes  )\n\n\t消息范围：WM_USER ~ WM_APP – 1\n\n- 应用程序自定义消息( Messages available for use by applications )\n\n\t消息范围：WM_APP ~ 0xBFFF\n\t\n- 应用程序字符串消息( String messages for use by applications )\n\n\t消息范围：0xC000 ~ 0xFFFF\n\t\n- 系统预留( Reserved by the system  )\n\n\t消息范围：0xFFFF ~\n\n### 常用Windows消息表\n\n- WM_CREATE( 0x0001 ): 创建一个窗口\n\n- WM_DESTROY( 0x0002 ): 销毁一个窗口\n\n- WM_SIZE( 0x0005 ): 改变一个窗口的大小\n\n- WM_PAINT( 0x000F ): 要求一个窗口重画自己\n\n- WM_NOTIFY( 0x004E ): 当某个控件的某个事件已经发生或这个控件需要得到一些信息时，发送此消息给它的父窗口\n\n- WM_KEYDOWN( 0x0100 ): 按下一个键\n\n- WM_KEYUP( 0x0101 ): 释放一个键\n\n- WM_COMMAND( 0x0111 ): 当用户选择一条菜单命令项或当某个控件的某个事件已经发生或这个控件需要得到一些信息时，发送此消息给它的父窗口\n\n- WM_TIMER( 0x0113 ): 发生了定时器事件\n\n- WM_HSCROLL( 0x0114 ): 当一个窗口标准水平滚动条产生一个滚动事件时发送此消息给那个窗口，也发送给拥有它的控件\n\n- WM_VSCROLL( 0x0115 ): 当一个窗口标准垂直滚动条产生一个滚动事件时发送此消息给那个窗口，也发送给拥有它的控件\n\n- WM_MOUSEMOVE( 0x0200 ): 移动鼠标\n\n- WM_LBUTTONDOWN( 0x0201 ): 按下鼠标左键\n\n- WM_LBUTTONUP( 0x0202 ): 释放鼠标左键\n\n- WM_LBUTTONDBLCLK( 0x0203 ): 双击鼠标左键\n\n- WM_RBUTTONDOWN( 0x0204 ): 按下鼠标右键\n\n- WM_RBUTTONUP( 0x0205 ): 释放鼠标右键\n\n- WM_RBUTTONDBLCLK( 0x0206 ): 双击鼠标右键\n\n\n","tags":["Windows编程"]},{"title":"C++多态的原理和实现","url":"/2019/04/13/C++多态的原理和实现/","content":"\n　多态（polymorphism）源自希腊语，从字面上理解就是多种形态，具体到C++这种面向对象（OOP）的语言中，其实就是“一个接口，多种实现（方法）”，多态是C++最重要的核心特性之一\n\n### 什么是多态？\n\n　C++中多态并不仅仅是单一的一种技术，而是多种技术的合称，多态可分为 **<u>静态多态</u>** 和 **<u>动态多态</u>** ，具体的分类情况如下：\n\n![](/img/C++/Polymorphism.png)\n\n　把函数实现和函数调用相关联称为 **绑定(binding)** ，静态多态和动态多态的关键区别就是 **绑定** 的时间点，当 **绑定** 发生在程序运行之前，由编译器完成就是 **早绑定(early-binding)** ，C语言只支持早绑定一种函数调用方式，当 **绑定** 发生在程序运行期间，就是 **晚绑定(late-binding/dynamic-binding/runtime-binding)**\n\n- **<u>静态多态</u>** 是指在编译期间就可以确定函数的调用地址，并生产代码，这就是静态的，也就是说地址是**早绑定**，静态多态也往往被叫做**静态联编**， **<u>泛型编程</u>** 和 **<u>函数重载</u>** 都属于静态多态\n\n- **<u>动态多态</u>** 则是指函数调用的地址不能在编译器期间确定，必须需要在运行时才确定，这就属于**晚绑定**，动态多态也往往被叫做**动态联编**\n\n### 静态多态\n\n- **函数重载**\nC语言并不支持函数重载，如果想对不同的数据类型int、double实现加法函数，通常要分别创建add_int()、add_double()这样不同的函数名，往往会增加编程工作量，C++开始支持函数重载，允许使用不同参数列表的多个函数同名，C++的构造函数就必须用到函数重载，编译器在实现函数重载时，会产生类似于add_int_、add_double_这样不同的内部名称，可以通过生成的汇编代码查看，C++允许通过参数列表来重载，但是不允许通过返回值来重载，因为有时编译器并不能从上下文来唯一确定 `add(a, b);` 的返回值类型\n\n```\n// 函数重载\nint add(int a, int b)\n{\n　return a + b;\n}\n\ndouble add(double a, double b)\n{\n　return a + b;\n}\n```\n\n- **模板(泛型编程)**\n模板(泛型编程)本身很容易理解，但要尤其注意的是模板的声明和定义要放在一起(.h)，也就是不支持分离式编译，STL模板实现全部也都是放在.h文件\n\nC++中一个 **编译单元(translation unit)** 是指一个.cpp文件以及它所include的所有.h文件，.h文件里的代码在预编译阶段会被扩展到包含它的.cpp文件里，然后编译该.cpp文件为一个.obj文件，.obj文件本身就已经是二进制代码，当编译器将工程里的所有.cpp文件以分离的方式编译完毕后，再由链接器进行链接成为一个可执行文件\n\n<u>模板的代码并不能直接被编译成二进制代码</u>，模板的编译需要一个具现化的过程，如果在.cpp文件中没有调用过模板函数，编译器完全不会编译关于模板函数的代码，如果模板使用分离式编译，在被调用的.cpp文件找不到模板的实现，编译器遇到未决符号会交给链接器，而模板所在.cpp文件因为没有被调用又不会去具现化模板，在链接阶段就一定会报错\n\n```\n// 泛型编程(模板)\n// typename也可以替换为class\ntemplate <typename T>\nT add(T a, T b)\n{\n　return a + b;\n}\n```\n\n### 动态多态\n\n首先看一段代码\n\n```\nclass Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Base::fun()\" << endl;\n　}\n};\n\nclass Derived : public Base\n{\n}\n\nint main()\n{\n　Base b;\n　Derived d;\n　\n　b.fun();   // 调用基类的fun(),打印Base::fun()\n　d.fun();   // 子类继承了基类的fun()且子类本身没有fun(),因此此处还是调用基类的fun(),打印Base::fun()\n　\n　return 0;\n}\n```\n\n- 在子类中重定义(隐藏)fun()函数，再看这段代码：\n\n```\nclass Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Base::fun()\" << endl;\n　}\n};\n\nclass Derived : public Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Derived::fun()\" << endl;\n　}\n}\n\nint main()\n{\n　Base b;\n　Derived d;\n　\n　b.fun();   // 调用基类的fun(),打印Base::fun()\n　// 子类虽然继承了基类的fun(),但是子类本身中fun()\n　// 此时构成了重定义,基类中的fun()被隐藏，调用的是子类的fun()\n　// 打印Derived::fun()\n　d.fun();\n　d.Base::fun();   // 加类的作用域限定符,调用基类的fun(),打印Base::fun()\n　\n　return 0;\n}\n```\n\n- 保持上面这段代码的类定义不变，用类指针类调用成员函数，分析执行结果发现，基类指针指向子类，却调用基类自己的fun函数打印Base::fun()，而不是子类的Derived::fun()，这就是因为上面讲的静态联编，其实在编译时期就将函数实现和函数调用关联起来，指针在编译时期是Base类的，自然调用Base类的fun()\n\n```\nclass Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Base::fun()\" << endl;\n　}\n};\n\nclass Derived : public Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Derived::fun()\" << endl;\n　}\n}\n\nint main()\n{\n　Base b;\n　Derived d;\n　Base *pb = &b;\n　Derived *pd = &d;\n　\n　pb->fun();   // pb指向基类,打印Base::fun()\n　pd->fun();   // pb指向子类,打印Derived::fun()\n　\n　pb = &d;   // 将基类指针指向子类\n　pb->fun();   // pb指向子类,却打印Base::fun()\n　\n　return 0;\n}\n```\n\n- 为了避免上一段代码中的这种情况，C++中引入了动态多态，通过**继承**和**虚函数**来实现，在程序运行期间(非编译期)判断所指针指向对象的实际类型，根据其实际类型调用相应的方法，具体格式就是使用**virtual关键字**修饰类的成员函数，指明该函数为虚函数，并且派生类需要重新实现该成员函数，编译器将实现动态绑定，以下为用虚函数实现的代码\n\n```\nclass Base\n{\npublic:\n　virtual void fun()\n　{\n　　cout << \"Base::fun()\" << endl;\n　}\n};\n\nclass Derived : public Base\n{\npublic:\n　void fun()\n　{\n　　cout << \"Derived::fun()\" << endl;\n　}\n}\n\nint main()\n{\n　Base b;\n　Derived d;\n　Base *pb = &b;\n　Derived *pd = &d;\n　\n　pb->fun();   // pb指向基类,打印Base::fun()\n　pd->fun();   // pb指向子类,打印Derived::fun()\n　\n　pb = &d;   // 将基类指针指向子类\n　pb->fun();   // pb实际指向子类,打印Derived::fun()\n　\n　return 0;\n}\n```\n\n　动态多态的实现有两个必要的绑定条件：\n\n- 必须在基类中定义虚函数\n- 必须通过基类类型的引用或者指针调用虚函数\n\n### 虚函数的实现原理\n\n　C++通过继承和虚函数来实现多态，编译器在编译的时候，会为每个包含虚函数的类创建一个虚表(vtable)，在虚表中存放每个虚函数的地址，编译器另外还为每个对象提供了一个虚表指针(vptr)，这个指针指向了对象所属类的vtable，在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向了所属类的vtable，从而在调用虚函数的时候，能够找到正确的函数\n\n![](/img/C++/vtable.png)\n\n　由于每个对象调用的虚函数都是通过vptr来索引的，因此vptr的正确初始化是非常重要的，在vptr没有正确初始化之前，不能够去调用虚函数，C++在类的构造函数中进行vtable的创建和vptr的初始化，在构造子类对象时，要先调用父类的构造函数，初始化父类对象的vptr，此时vptr指向父类的vtbale，当执行子类的构造函数时，子类对象的vptr被初始化，指向子类的vtbale\n\n　每个包含虚函数的类对象的内存空间中，首先会存储虚表指针(vptr)，然后才存储成员变量，因此在计算sizeof大小的时候，需要增加4个字节（32位系统下）\n\n### 构造函数不可能是虚函数\n\n　虚函数实现本身就依赖虚表指针(vptr)，而vptr的初始化需要造构造函数中完成，调用构造函数时vptr还没有初始化，因此构造函数不可能是虚函数\n\n### 析构函数常常是虚函数\n\n　当某个类对象被注销时，编译器会自动顺序调用该类以及其父类的析构函数，而不会调用派生类的析构函数，如果析构函数不为虚的话，就不能正确识别对象类型，从而不能正确销毁对象释放资源，将基类的析构函数声明为虚函数之后，派生类的析构函数也自动成为虚析构函数\n","tags":["C++"]},{"title":"单例(Singleton)模式","url":"/2019/04/12/单例(Singleton)模式/","content":"\n　对于具有一定开发经验的程序员，几乎都在项目中使用或者接触过单例模式，单例模式是软件设计模式中最常用的模式之一\n\n　在计算机系统中，线程池、缓存、日志对象、打印机、显卡的驱动程序对象等常被设计成单例实现，这些应用都或多或少具有资源管理器的功能，比如每台计算机一定只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中，选择单例模式就是为了避免不一致状态，避免发生冲突\n\n### 单例模式的定义\n\n　单例模式涉及到一个单一的类(单例类)，该类负责创建自己的对象，同时确保只有单个对象被创建，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象，可以概括为以下三点：\n\n- 单例类只能有一个实例\n\n- 单例类必须自己创建自己的唯一实例\n\n- 单例类必须给所有其他对象提供这一实例的访问方式\n\n![](/img/DesignPattern/Singleton.jpg)\n\n### 单例模式的代码实现(C++)\n\n　单例模式有两种实现方式 —— 懒汉方式和饿汉方式：　\n\n- 懒汉方式：在第一次用到类实例的时候才会去实例化，访问线程比较少时，可使用懒汉方式，用时间换空间\n\n```\n// 单例模式的懒汉方式实现\n// 为了保证线程安全，需要加锁\n\nclass Singleton\n{\nprotected:\n　Singleton();\npublic:\n　static pthread_mutex_t mutex;\n　static Singleton* GetInstance();\nprivate:\n　static Singleton* p;\n}\n\npthread_mutex_t Singleton::mutex;\nSingleton* Singleton::p = NULL;\n\nSingleton::Singleton()\n{\n　pthread_mutex_init(&mutex);\n}\n\nSingleton* Singleton::GetInstance()\n{\n　if( p == NULL)\n　{\n　　pthread_mutex_lock(&mutex);\n　　p = new Singleton();\n　　pthread_mutex_lock(&mutex);\n　}\n　\n　return p;\n}\n\n```\n\n- 饿汉方式：单例类定义的时候就进行实例化，访问线程比较多时，可使用饿汉方式，用空间换时间\n\n```\n// 单例模式的饿汉方式实现\n// 饿汉方式本身就是线程安全的\n\nclass Singleton\n{\nprotected:\n　Singleton() {}\npublic:\n　static Singleton* GetInstance();\nprivate:\n　static Singleton* p;\n}\n\nSingleton* Singleton::p = Singleton();\n\nSingleton* Singleton::GetInstance()\n{\n　return p;\n}\n\n```\n\n- 单例类模板的饿汉方式实现\n\n```\ntemplate <typename T>\nclass Singleton\n{\nprotected:\n　Singleton() {}\npublic:\n　static T* GetInstance();\nprivate:\n　static T* m_pInstance;\n}\n\ntemplate <typename T>\nT* Singleton<T>::m_pInstance = new T;\n\ntemplate <typename T>\nT* Singleton::GetInstance()\n{\n　return m_pInstance;\n}\n```\n\n","tags":["设计模式"]},{"title":"C++关键字用法总结","url":"/2019/04/12/C++关键字用法总结/","content":"\n### 关键字extern\n\n　C++支持分离式编译机制，一个完整的程序或项目可以分割为若干个.cpp源文件，每个.cpp源文件单独编译生成.obj目标文件，最后将所有.obj目标文件链接成一个单一的可执行文件，如果一个.cpp源文件要使用另一个.cpp源文件定义的变量，应该如何调用？\n　**C++中解决方法是将 `变量声明` 与 `变量定义` 分离**\n\n　`变量声明` 规定了变量的类型和名字，但仅仅只是告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存，使得名字为本程序文件所知道，比如一个文件如果想使用在另外一个文件中定义的变量，则必须包含对那个变量名字的声明，关键字extern就被用来实现 `变量声明`\n\n　`变量定义` 同样规定了变量的类型和名字，不同于 `变量声明` 的是，`变量定义` 还会给变量申请存储空间，还可能给变量赋予一个初始值，如果多个文件中都定义了同一个变量，编译时会产生变量重定义冲突错误\n\n\t```\n\textern int i;   // 变量声明\n\tint j;   // 变量定义\n\t\n\t// 需要注意!\n\t// 任何一个显式初始化的声明都将成为定义，而不管有没有extern\n\textern double pi = 3.1415926;\n\t```\n\n　关键字extern主要有以下三种使用方法：\n\n- 引用同一个文件中的变量\n\n```\n#include <stdio.h>\n\nint func();\n\nint main()\n{\n　func();\n　extern int num;   // 引用同一个文件中的变量\n　printf(\"%d\", num);\n　\n　return 0;\n}\n\nint num = 3;\n\nint func()\n{\n　printf(\"%d\\n\",num);\n}\n```\n\n- 引用另一个文件中的变量\n\n```\n// main.cpp\n\n#include <stdio.h>\n\nint main()\n{\n　extern int num;   // 引用另一个文件中的变量\n　printf(\"%d\",num);\n　\n　return 0;\n}\n```\n\n```\n// branch.cpp\n\n#include <stdio.h>\n\nint num = 5;\n```\n\n- 引用另一个文件中的函数\n\n```\n// main.cpp\n\n#include <stdio.h>\n\nint main()\n{\n　extern void func();   // 引用另一个文件中的函数\n　func();\n　\n　return 0;\n}\n```\n\n```\n// branch.cpp\n\n#include <stdio.h>\n\nvoid func()\n{\n　printf(\"func\");\n}\n```\n\n### 关键字const\n\n- const定义的常量，不能被修改；\n\n```\nconst int a;\n```\n\n- const修饰函数参数，防止被意外修改；\n\n```\nvoid func(const int a);\n```\n\n- const修饰函数返回值，则返回值不能被直接修改，且只能赋值给const修饰的同类变量；\n\n```\nconst int x = const int func(const int a);\n```\n\n- const修饰类成员变量，只能在定义的时候进行初始化，并且在程序的执行过程中不能被再次赋值；\n\n- const修饰类成员函数，放在类成员函数声明之后，保证不会修改该对象的成员变量\n\n```\nvoid fun(int val) const;\n// 任何不会修改类成员变量的类成员函数都应该使用const修饰\n// const成员函数不能调用非const成员函数\n```\n\n### 关键字static（面向过程）\n\n　关键字static的作用主要可以分为两方面，一方面是面向过程，另一方面是面向对象，先介绍面向过程：\n\n- **静态全局变量**\n\n　在全局变量前加上关键字static，该变量就被定义为静态全局变量，静态全局变量在全局/静态存储区初始化，作用域仅限于定义的文件，具有内部链接性\n\n- **静态局部变量**\n\n　在代码块中定义的变量前加上关键字static，该变量就被定义为静态局部变量，他始终驻留在全局/静态存储区，直到程序运行结束\n\n- **静态函数**\n\n　静态函数的声明方法也是在函数前加上关键字static，作用域仅限于定义的文件，不能被其他文件引用，不会发生冲突\n\n### 关键字static（面向对象）\n\n- **静态成员变量**\n\n　对于非静态成员变量，每个类对象都有自己的拷贝，而静态成员变量只有一份拷贝，存在于全局/静态存储区，由该类型的所有对象共享，静态成员变量定义时要分配空间，所以不能在类声明中定义，只能在类外定义\n\n- **静态成员函数**\n\n　普通成员函数一般都隐藏了一个this指针，this指针指向类对象本身，因为普通成员函数总是具体的属于某个类的具体对象的，而静态成员函数不具有this指针，因此他无法访问属于类对象的非静态成员变量，也无法访问非静态成员函数\n\n　一切不需要实例化就可以有确定行为方式的函数都应该设计成静态的，比如封装一些算法，或者实现一些设计模式\n\n### 关键字virtual\n\n 类的多态特性是支持面向对象的语言最主要的特性，C++中的关键字virtual是实现多态的重要方式\n\n- 虚函数\n　虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数\n\n- 纯虚函数\n　在基类中不对虚函数给出实现，把它声明为纯虚函数，它的实现留给该基类的派生类去完成，含有纯虚函数的类构成抽象类\n\n- 虚继承\n　在派生类继承基类时，加上一个virtual关键词则为虚拟基类继承，虚继承主要用于一个类继承多个类的情况，避免重复继承同一个类两次或多次\n\n### 关键字struct\n\n　在C语言中，struct用来定义一个结构体，仅仅是一个包含不同数据类型的数据结构，C++中的struct对C语言中的struct进行了扩充，C++中的struct结构体能包含成员函数，能继承，也能实现多态，其实已经几乎实现了class的功能，在C++中struct和class的区别主要是以下两点\n\n- struct的默认的继承访问权限是public，而class是private\n\n- struct的默认的数据访问控制是public，而class是private\n\n### 关键字inline\n\n　inline关键字修饰的函数称为“内联函数”，内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样\n\n　函数调用语句和直接把函数中的代码重新抄写一遍相比，带来了程序运行时间上的额外开销，一般情况下，这个开销可以忽略不计，如果一个函数内部没有几条语句，执行时间本来就非常短，那么这个函数调用产生的额外开销和函数本身执行的时间相比，就显得不能忽略了，假如这样的函数在一个循环中被上千万次地执行，函数调用导致的时间开销可能就会使得程序运行明显变慢\n\n### 作用域运算符::\n\n　作用域运算符::是运算符中等级最高的，可以分成三种：\n\n- 全局作用域符\n\n　当全局变量在某个局部作用中与其中某个局部变量重名，那么就可以用全局作用域符::来区分\n\t\n\t```\n\tint x = 1;   // 全局变量\n\t\n\tvoid func()\n\t{ \n\t　int x = 1;   // 局部变量\n\t　x = x + x;   // 局部变量，代码块中局部变量会覆盖全局变量\n\t　::x = ::x + x;   // 前两个x为全局变量，最后的x为局部变量\n\t}\n\t```\n\n- 类作用域符\n\n　为了避免不同的类有名称相同的成员，可以用类作用域符进行区分，类作用域符前面是类的名称，后面是该类的成员名称\n\n\t```\n\tclass A\n\t{\n\tpublic:\n\t　void func();\n\t}\n\t\n\tclass B\n\t{\n\tpublic:\n\t　void func();\n\t}\n\t\n\tvoid A::func()\n\t{\n\t　// ...\n\t}\n\t\n\tvoid B::func()\n\t{\n\t　// ...\n\t}\n\t```\n\n- 命名空间作用域符\n\n　命名空间作用域符可以区分不同命名空间中的成员，命名空间作用域符前面是命名空间的名称，后面是该命名空间的成员名称\n\n\t```\n\t#include <iostream>\n\tusing namespace std;\n\t\n\tnamespace A\n\t{\n\t　int x = 1;\n\t　\n\t　void fun()\n\t　{\n\t　　cout << \"A\" << endl;\n\t　}\n\t}\n\t\n\tnamespace B\n\t{\n\t　int x = 2;\n\t　\n\t　void fun()\n\t　{\n\t　　cout << \"B\" << endl;\n\t　}\n\t　\n\t　void fun2()\n\t　{\n\t　　cout << \"BB\" << endl;\n\t　}\n\t}\n\t\n\tint main()\n\t{\n\t　cout << A::x << endl;\n\t　cout << B::x << endl;\n\t\n\t　using namespace B;\n\t\n\t　A::fun();\n\t　fun();\n\t　fun2();\n\t　\n\t　return 0;\n\t}\n\t```\n\n","tags":["C++"]},{"title":"C++的内存分配和链接性","url":"/2019/04/11/C++的内存分配和链接性/","content":"\n　C++程序（包括其他语言的程序）主要由代码和数据两部分组成，代码存储在是内存代码段中，数据根据类型的不同存储在不同的其他内存段中\n\n### C++的内存分配\n\n![](/img/C++/memory.png)\n\n- **<u>代码段（.text）</u>**\n\n代码段存放程序执行代码，在代码段中也可能包含一些只读常量\n\n- **<u>数据段（.data）和只读数据段（.rodata）</u>**\n\n数据段是已经初始化的全局变量和静态变量的存储区，只读数据段存放的是只读数据，一般是程序里面的只读变量（const修饰的变量），操作系统可以将只读数据段的属性映射成只读，对于这个段的任何修改操作都会被视为非法操作，从而保证了程序的安全性\n\n- **<u>BSS段（.bss）</u>**\n\n在C语言中，全局变量和静态变量分为初始化的和未初始化的，未初始化的全局变量和静态变量会被用0来填充，存储在BSS(Block Started by Symbol)数据段，已经初始化的变量放在相邻的另一个数据段，在C++中已经没有这个区分，初始化的和未初始化的变量都共享同一块内存区\n\n- **<u>堆（.heap）</u>**\n\n由分配程序员分配管理的内存块存储区，堆中内存块的释放编译器不会检查，需要在代码中自己控制，一般一个new就需要对应一个delete，一个malloc就需要对应一个free，否则会造成内存泄漏，在应用程序结束后，会自动回收\n\n- **<u>栈（.stack）</u>**\n\n由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区，栈通常存储局部变量、函数参数等，在一个进程中，位于虚拟地址空间顶部的是栈，栈的地址向下生长\n\n```\n#include <iostream>\nusing namespace std;\n\nconst int aa = 1;   // 只读数据段\n\nint bb = 2;          // 数据段\nstatic int cc = 3;   // 数据段\n\nint dd;          // BSS段\nstatic int ee;   // BSS段\n\nint main()\n{\n　int a;   // 栈\n　int b;   // 栈\n\n　static int c = 0;   // 数据段\n　static int d;       // BSS段\n\n　int *p = new int[5];   // 堆\n　delete []p;            // 一定要释放，否则会造成内存泄漏\n    \n　return 0;\n}\n```\n\n### 堆和栈的区别\n\n- **管理方式**\n\n栈由编译器自动管理，无需手动控制；\n堆由new/delete来控制，申请后没有释放内存容易造成memory leak；\n\n- **空间大小**\n\n一般在32位系统下，堆内存可以达到3G的空间（顶部的1G是内核空间不能读写），从这个角度来看堆内存几乎是没有什么限制的；\n对于栈来讲，一般都是有一定的空间大小的，例如在CentOS下面，默认的栈空间大小是8MB，也可以通过 `ulimit` 修改栈的大小；\n\n- **碎片问题**\n\n频繁的new/delete势必会造成堆内存空间的不连续，从而造成大量的碎片；\n而栈则不存在这个问题；\n\n- **生长方向**\n\n栈的生长方向是向下的，是向着内存地址减小的方向增长；\n堆的生长方向是向上的，也就是向着内存地址增加的方向；\n\n- **分配方式**\n\n堆都是动态分配的，没有静态分配的堆；\n栈有静态分配和动态分配2种分配方式，都由编译器实现；\n\n- **分配效率**\n\n计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，栈的分配效率比较高；\n而堆的分配效率比较低；\n\n### malloc()函数的工作机制\n\n　从操作系统层面来看，进程分配内存有两种方式，分别由brk()和mmap()这两个系统调用完成，这两个系统调用分配的都是虚拟内存，并没有分配真实的物理内存，在第一次访问分配的虚拟地址空间的时候，会发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系\n\n　从C++代码的层面来看，进程的内存可以通过库函数malloc()来分配，但是如果每次调用malloc()都要触发系统调用，性能的开销会比较大，因此实际上管理者进程堆内存的是C运行库(glibc)，glibc会预先和操作系统申请内存空间，将可用的内存块连接成的一个长长的空闲链表，调用malloc()函数时，对于小于128K的请求，glibc沿空闲链表寻找一个大到足以满足用户请求所需要的内存块，然后将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节），将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上，调用free()函数时，它将用户释放的内存块连接到空闲链上，到最后空闲链会被切成很多的小内存片段，这时如果用户申请一个大的内存片段(大于128K)，那么空闲链上可能没有可以满足用户要求的片段，于是，malloc()函数请求延时，并开始在空闲链上检查各内存片段，将相邻的小空闲块合并成较大的内存块，但如果合并之后还是不够申请大小，分配器会调用mmap()，向内核请求额外的堆存储器，分配器将额外的存储器转换为一个大的空闲块，然后将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中\n\n　因此也可以看到，malloc()函数存在内存分配不成功的情况，常用的解决办法是，在使用内存之前检查指针是否为NULL，如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理\n\n### new和malloc的区别\n\n　new和malloc都可以用来申请动态内存，但两者实际上在使用的方法是不同的，malloc是C语言中的标准库函数，而new是C++中引入的运算符\n\n- **返回类型**\n\nmalloc的函数原型是：`extern void *malloc(unsigned int num_bytes)`，返回类型未确定类型的指针，需要进行强制转换才能使用：`int *p = (int *) malloc (sizeof(int))`，否则编译会不通过，而new返回指定类型的指针：`int *p = new int`\n\n- **计算大小**\n\nmalloc函数必须由我们计算要字节数：`int *p = (int *) malloc (sizeof(int) * 100)`，而new会自动计算大小：`int *p = new int[100]`\n\n- **效率比较**\n\nnew可以认为是malloc()加构造函数的执行(对应的delete是析构函数加free()的执行)，对象构造完成后，返回一个指向该对象的指针，new底层实际上还是调用了malloc()函数\n\n### C++的链接性\n\n　C++栈中存储的自动变量一定是无链接性的，而数据段存储的变量按照链接性可以分为三种，分别是：外部链接性，内部链接性和无链接性\n\n- **外部链接性**\n\n外部链接性的变量在代码块之外声明，不带static，具有多文件作用域；\n\n- **内部链接性**\n\n内部链接性的变量同样在代码块之外声明，用关键字static或者const修饰，作用域仅限于单文件；\n\n- **无链接性**\n\n无链接性的静态变量在代码块中声明，用关键字static修饰，作用域仅限于声明的代码块中\n\n\n```\n#include <iostream>\nusing namespace std;\n\nint x = 1;       // 声明外部链接性的变量\nstatic int y;    // 声明内部链接性的变量\n\nint func()\n{\n　static int z;   // 声明无链接的变量\n}\n\nint main()\n{\n　return 0;\n}\n```\n\n","tags":["C++"]},{"title":"理解Windows句柄","url":"/2019/04/10/理解Windows句柄/","content":"\n　开始Windows编程半年多，几乎每天都需要和各种Windows句柄打交道，一直把Windows句柄当做一个指针来使用，虽然在句柄的使用上没遇到问题，认识却停留在一知半解的层面，趁这段离职的时间，终于可以深入把Windows句柄理解清楚\n\n### 什么是Windows句柄\n\n　首先来看下微软自己对于句柄的定义：\n\n```\n《Microsoft Windows 3 Developer's Workshop》 (by Richard Wilton) [Microsoft Press]\n在Windows环境中，句柄是Windows系统用来标识被应用程序所建立或使用的对象的唯一整数\n这些对象包括：\n模块(module)、任务(task)、实例 (instance)、对话框(dialog)、文件(file)、\n内存块(block of memory)、菜单(menu)、控制(control)、字体(font)、\n资源(resource)[包括图标(icon)，光标 (cursor)，字符串(string)等]、\nGDI对象(GDI object)[包括位图(bitmap)，画刷(brush)，元文件（metafile），\n调色板(palette)，画笔(pen)，区域 (region)，以及设备描述表(device context)]\n```\n\n　数值上，句柄是一个32位的整数（32位系统下），逻辑上，句柄相当于指针的指针，实际上，句柄是Windows系统在内存中维护的一个对象（窗口等）内存物理地址列表的整数索引，是Windows中各个对象的一个唯一的、固定不变的ID（所谓“唯一”、“不变”是指在程序的一次运行过程中），通过句柄就可以找到对象在内存中的位置，从而去对内存中的对象进行操作\n　\n　注意句柄是对象生成时Windows系统指定分配的，属性是只读的，程序员不能修改句柄，程序员只能通过句柄调用系统提供的服务（即API调用），不能像使用指针那样，做其它的事\n\n### 为什么需要Windows句柄\n\n　或许很多人会问，既然句柄的作用相当于指针，干脆直接获取对象在内存中的首地址，不就可以随时用这个地址访问对象了，为什么还需要通过句柄找到指针多此一举？\n\n　其实这样在Windows系统中行不通！\n\n　Windows系统是一个以虚拟内存为基础的操作系统，很多时候进程的代码和数据并不全部装入内存，进程的某一段装入内存后，还可能被替换出内存，当再次需要时，再装入内存，两次装入的地址基本上是不一样的，也就是说，同一对象在内存中的地址会变化，那么程序怎么才能准确地访问到对象呢？为了解决这个问题，Windows引入了句柄\n\n　Windows系统为每个进程在内存中分配一定的空间，用来存放各个句柄，即各个32位无符号整型值（32位系统下），每个32位无符号整型值相当于一个指针，指向内存中的一个区域，而区域中存放的正是对象在内存中的地址，当对象在内存中的位置发生变化时，区域中存放的值被更新，变为当前时间点对象在内存中的地址，而在这个过程中，区域的位置以及对应句柄的值是不发生变化的，这个过程机制用下面的2张图来形象展示\n\n- 图1：程序运行到某时间点的内存快照\n\n![](/img/Windows/HANDLE_01.png)\n\n- 图2：程序往后运行到另一时刻时的内存快照，对象在内存中的位置已经发生变化，而区域的位置以及对应句柄的值没有发生变化\n\n![](/img/Windows/HANDLE_02.png)\n\n　通过这2张图就明白了句柄的作用：有一个固定的标识（句柄），指向一个固定的位置（区域），而区域中存放的值可以动态地变化（虚拟内存），他时刻记录着当前时间点对象在内存中的地址，这样无论对象的位置在内存中如何变化，只要掌握了句柄的值，就可以找到区域，进而找到该对象进行操作\n\n### 从源代码分析Windows句柄\n\n　在WinNT.h中，定义了大部分Windows系统里一些内部结构，包括通用句柄的结构\n\n```\ntypedef void *PVOID;\n \n#ifdef STRICT\ntypedef void *HANDLE;\n#define DECLARE_HANDLE(name) struct name##__ { int unused;};\ntypedef struct name##__ *name\n#else\ntypedef PVOID HANDLE;\n#define DECLARE_HANDLE(name) typedef HANDLE name\n#endif\n```\n\n　在Windef.h中做了特殊句柄的定义\n\n```\n#if !defined(_MAC) || !defined(GDI_INTERNAL)\nDECLARE_HANDLE(HFONT);\n#endif\nDECLARE_HANDLE(HICON);\n#if !defined(_MAC) || !defined(WIN_INTERNAL)\nDECLARE_HANDLE(HMENU);\n#endif\nDECLARE_HANDLE(HMETAFILE);\nDECLARE_HANDLE(HINSTANCE);\ntypedef HINSTANCE HMODULE;      /* HMODULEs can be used in place of HINSTANCEs */\n#if !defined(_MAC) || !defined(GDI_INTERNAL)\nDECLARE_HANDLE(HPALETTE);\nDECLARE_HANDLE(HPEN);\n#endif\nDECLARE_HANDLE(HRGN);\nDECLARE_HANDLE(HRSRC);\nDECLARE_HANDLE(HSTR);\nDECLARE_HANDLE(HTASK);\nDECLARE_HANDLE(HWINSTA);\nDECLARE_HANDLE(HKL);\n```\n\n　微软把通用句柄HANDLE定义为void指针，显然是不想让人知道句柄的真实类型，但是通过分析代码可以发现，句柄就是一种指向结构体的指针，由于指向结构体指针可以强制截断只获取第一个字段，这里的struct结构体绝对不止一个字段，但是可以很容易猜到结构体的第一个字段就是逻辑地址（指针）\n\n### 窗口句柄和窗口指针\n\n　窗口对象是一个继承于CWnd类的C++类的对象，是Windows编程中最常用的对象，窗口句柄和窗口指针可以通过对方来相互获取\n\n- 从窗口指针获取窗口句柄\n\n```\nHWND hWnd;\nhWnd = GetDlgItem(IDC_STATIC_WND)->GetSafeHwnd();\n```\n\n- 从窗口句柄获取窗口指针\n\n```\n// HBITMAP m_hBitmap\nCBitmap *pBitmap = FromHandle(m_hBitmap);\n```\n\n\n","tags":["Windows编程"]},{"title":"从函数指针到回调函数","url":"/2019/04/09/从函数指针到回调函数/","content":"\n\n　C++(包括C语言)中最灵活的技术就是指针，在操作一个对象或者数组时，我们常常用到指针，可以给编程带来很多灵活性，而指针不仅仅能指向对象或者固定数据类型，还可以指向函数，这就是函数指针\n\n　有了函数指针，我们可以通过指针调用函数，更重要的是我们可以将函数指针作为参数传递给函数，进而可以实现回调函数(callback)功能，所以有了函数指针，我们的程序可以设计的更加灵活，这也正是C++的魅力(当然指针是一把双刃剑，使用不当也会引发灾难:)\n\n## 函数指针\n\n### 函数指针的简单定义\n\n　C++中函数声明由3部分组成，分别是函数的参数、返回类型和函数名，其中参数和返回类型这两项决定了函数类型，函数类型与函数名无关，以下例子中函数类型为int(int)\n\n```\n// 函数声明\nint PrintInt(int i);\n\n// 函数定义\nint PrintInt(int i)\n{\n　cout << i << endl;\n　return i;\n}\n```\n\n　声明一个指向某种函数类型的函数指针非常简单，只需要用指针替换函数名即可，以下例子中声明了一个函数指针，可以指向函数类型为int(int)的函数，这里要注意，函数指针 `(*pFunc)` 两边的括号必不可少，否则声明的就不再是函数指针，而是返回值为(int *)型指针的函数\n\n```\n// 声明函数指针\nint (*pFunc)(int i);   // 未初始化\n\n// 注意: pFunc不是函数指针，而是返回值为(int *)的函数\nint *pFunc(int i);\n```\n\n　声明函数指针完成后，函数指针处于未初始化的状态，需要将函数地址赋值给函数指针，然后就可以通过函数指针来调用函数\n\n```\n// 声明函数指针\nint (*pFunc)(int i);   // 未初始化\n\n// 声明并定义函数\nint PrintInt(int i)\n{\n　cout << i << endl;\n　return i;\n}\n\nint main()\n{\n　// 将函数地址赋值给函数指针\n　pFunc = PrintInt;   // pFunc = &PrintInt; 也可以\n　\n　// 通过函数指针来调用函数\n　pFunc(1);   // (*pFunc)(1); 也可以\n　\n　return 0;\n}\n```\n\n　其实在声明和定义函数的时候，函数名就是一个函数指针，只不过是一个常量函数指针，而在声明函数指针的时候，声明的是一个变量函数指针\n\n### 函数指针的typedef定义\n\n　声明函数指针的格式为 `返回值 (*函数指针名)(参数列表)`，每次需要声明一个函数指针的时候，都需要这样声明一长串显然很麻烦，可以用typedef关键字，定义某一种类型的函数指针，给它一个别名，然后用别名去声明函数指针就会像声明一个int型变量一样方便\n\n```\n// 使用typedef时，PTRFUNC不再是具体指针\n// PTRFUNC表示指向某种函数类型的函数指针类型 (拗口)\ntypedef int (*PTRFUNC)(int i);\n\n// 声明并定义函数\nint PrintInt(int i)\n{\n　cout << i << endl;\n　return i;\n}\n\nint main()\n{\n　// 通过PTRFUNC声明指针，并赋值\n　PTRFUNC pFunc = PrintInt;\n　\n　// 通过函数指针来调用函数\n　pFunc(1);\n　\n　return 0;\n}\n```\n\n### 函数指针作为函数的参数\n\n　有了函数指针，我们就可以像传递普通指针那样将一个函数作为参数传递给另一个函数，这大大的增加了我们编程的灵活性\n\n```\n// 定义int(int,int)类型的函数指针\ntypedef int (*CALLFUNC)(int,int);\n\n// CALLFUNC类型的函数作为参数\nvoid HandleFunc(CALLFUNC pFunc,int x,int y)\n{\n　cout << pFunc(x, y) << endl;\n}\n\n// 加法函数\nint AddFunc(int x,int y)\n{\n　return (x + y);\n}\n\n// 减法函数\nint SubFunc(int x,int y)\n{\n　return (x - y);\n}\n\nint main()\n{\n　// 将函数指针作为参数传递给函数\n　// &符号可以省略\n　HandleFunc(&AddFunc, 2, 1);\n　HandleFunc(&SubFunc, 2, 1);\n　\n　return 0;\n}\n```\n\n## 回调函数\n\n　掌握了函数指针，以及将函数指针作为参数进行传递的方法，我们就能实现函数指针最有用的功能 —— 回调函数(callback)\n\n　对于很多C++初学者来说，往往会觉得回调函数很神秘，其实要完全搞清楚回调函数只需要明白两个问题：\n\n> - 什么是回调函数？\n> \n> - 为什么要使用回调函数？\n\n### 什么是回调函数？\n\n　网上对于回调函数的定义五花八门，简而言之，回调函数就是一个通过函数指针调用的函数，如果你把函数指针作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数\n\n### 为什么要使用回调函数？\n\n　同样用一句话概括使用回调函数的最大作用，就是实现通知机制 (除此之外，回调函数还可以调用者和被调用者解耦)\n\n　关于调用普通函数和回调函数，我们用订蛋糕做个比喻，调用普通函数就好像你直接去蛋糕店订一个蛋糕，订完之后，你并不知道蛋糕什么时候会做好，所以你就需要一直在蛋糕店等着，一直到蛋糕做好了，才能取蛋糕；而回调函数就好像你去蛋糕店订一个蛋糕，这时蛋糕店会留下你的联系方式，当蛋糕做好了，蛋糕店就会给你打电话，让你去取蛋糕\n\n```\n### 调用普通函数 ###\n\n// 模拟蛋糕店类\nclass Baker\n{\npublic:\n　Baker();   // 构造函数\n　bool MakeCake();   // 做蛋糕函数，如果做好了返回true，否则返回false　\nprivate:\n　int m_iTime;   // 做蛋糕的时间\n　static const int m_iMaxTime = 10;   // 假设10分钟做完蛋糕\n};\n\nBaker::Baker():m_iTime(0){}\n\nbool Baker::MakeCake()\n{\n　// 每次调用该函数，m_iTime+1\n　m_iTime += 1;\n　\n　if (m_iTime == m_iMaxTime)\n　{\n　　cout << \"蛋糕做好了!\" << endl;\n　　return true;\n　}\n　\n　return false;\n}\n\n// 客户取蛋糕函数\nvoid GetMyCake()\n{\n　cout << \"我来取蛋糕啦!\" << endl;\n}\n\nint main()\n{\n　// 创建一个蛋糕店\n　Baker baker;\n\t\n　// 做蛋糕\n　while(1)\n　{\n　　// 客户如果想第一时间知道蛋糕做没做好，就必须每时每刻查看蛋糕的情况\n　　if( baker.MakeCake() )\n　　{\n　　　GetMyCake();\n　　　break;\n　　}\n　　else\n　　{\n　　　cout << \"蛋糕没做好\" << endl;\n　　}\n　}\n\n　return 0;\n}\n```\n\n　我们如果想要第一时间知道蛋糕有没有做好，就必须一直查询蛋糕有没有做好，换句话说，我们不能去干别的事情，如果这是一个线程的话，那么这个线程在这段时间就不能做其他事情，至少不能100%专注做别的事情，因为必须保持关注蛋糕有没有做好，这显然很低效，而使用回调函数，就可以实现通知机制，大大提升效率\n\n```\n### 回调函数 ###\n\n// 声明回调函数\ntypedef void (*CALLBACKFUNC)(void);  \n\n// 模拟蛋糕店类\nclass Baker\n{\npublic:\n　Baker();   // 构造函数\n　void MakeCake();   // 做蛋糕函数\n　void Invoke(CALLBACKFUNC);   // 注册回调函数：留下订蛋糕的人的联系方式\n　void Notify();   // 通知订蛋糕的人\nprivate:\n　int m_iTime;   // 做蛋糕的时间\n　static const int m_iMaxTime = 10;   // 假设10分钟做完蛋糕\n　CALLBACKFUNC m_pfCallBack;   // 回调函数\n};\n\nBaker::Baker():m_iTime(0){}\n\nvoid Baker::MakeCake()\n{\n　while(m_iTime < m_iMaxTime)\n　{\n　　// 每次调用该函数，m_iTime+1\n　　m_iTime += 1;\n　}\n　\n　cout << \"蛋糕做好了!\" << endl;\n　\n　Notify();\n}\n\nvoid Baker::Invoke(CALLBACKFUNC pFunc)\n{\n　m_pfCallBack = pFunc;\n　cout << \"留下了你的联系方式!\" << endl;\n}\n\nvoid Baker::Notify()\n{\n　if(m_pfCallBack)\n　　m_pfCallBack();\n}\n\n// 客户取蛋糕函数\nvoid GetMyCake()\n{\n　cout << \"我来取蛋糕啦!\" << endl;\n}\n\nint main()\n{\n　// 创建一个蛋糕店\n　Baker baker;\n\n　// 注册：留下联系方式\n　baker.Invoke(GetMyCake);\n　\n　// 注册之后，客户就不需要实时查询了\n　cout << \"好了请通知我!\" << endl;\n　\n　// 做蛋糕\n　baker.MakeCake();\n　\n　return 0;\n}\n```\n\n　在类中使用回调函数，先要注册回调函数，然后在某项任务完成以后，调用回调函数实现通知机制，比如我们做异步加载时，如果我们需要某个资源，就可以去加载线程注册一下，然后主线程继续做其他工作，加载线程加载完需要的资源之后，通过回调函数通知主线程，这样加载和主要功能就可以同时进行，大大的提升了用户体验\n\n\n","tags":["C++"]}]